./backend/monolith/package.json:    "setup-anthropic-key": "node scripts/setup-anthropic-key.js",
./backend/monolith/package.json:  "keywords": [
./backend/monolith/package.json:    "jsonwebtoken": "^9.0.2",
./backend/monolith/scripts/telegram-auth.js:          password: async () => {
./backend/monolith/scripts/telegram-auth.js:            // If 2FA is enabled, ask for password
./backend/monolith/scripts/telegram-auth.js:            return await input.text('Enter your 2FA password: ');
./backend/monolith/scripts/telegram-auth.js:        console.log('\nüîí 2FA enabled. Asking for password...');
./backend/monolith/scripts/telegram-auth.js:        const password = await input.text('Enter your 2FA password: ');
./backend/monolith/scripts/telegram-auth.js:            password: async () => password,
./backend/monolith/scripts/telegram-auth.js:      console.log('\nüí° 2FA password is incorrect. Please try again.');
./backend/monolith/scripts/verify-env-pm2.js:        const [key, ...valueParts] = trimmed.split('=')
./backend/monolith/scripts/verify-env-pm2.js:        if (key && valueParts.length > 0) {
./backend/monolith/scripts/verify-env-pm2.js:          if (!process.env[key]) {
./backend/monolith/scripts/verify-env-pm2.js:            process.env[key] = value
./backend/monolith/scripts/setup-notification-tables.js:  password: process.env.INTEGRAM_PASSWORD || 'd'
./backend/monolith/scripts/setup-notification-tables.js:    await client.authenticate(CONFIG.login, CONFIG.password)
./backend/monolith/scripts/setup-unified-interface-tables.js:  password: process.env.INTEGRAM_PASSWORD || 'd'
./backend/monolith/scripts/setup-unified-interface-tables.js:        password: CONFIG.password
./backend/monolith/scripts/mcp/headhunter-server.js:   * Set OAuth access token (optional, for authenticated requests)
./backend/monolith/scripts/mcp/headhunter-server.js:  setAccessToken(token) {
./backend/monolith/scripts/mcp/headhunter-server.js:    this.accessToken = token;
./backend/monolith/scripts/mcp/headhunter-server.js:    name: 'hh_set_access_token',
./backend/monolith/scripts/mcp/headhunter-server.js:    description: 'Set OAuth access token for authenticated requests (optional)',
./backend/monolith/scripts/mcp/headhunter-server.js:        token: {
./backend/monolith/scripts/mcp/headhunter-server.js:          description: 'OAuth access token'
./backend/monolith/scripts/mcp/headhunter-server.js:      required: ['token']
./backend/monolith/scripts/mcp/headhunter-server.js:      case 'hh_set_access_token':
./backend/monolith/scripts/mcp/headhunter-server.js:        client.setAccessToken(args.token);
./backend/monolith/scripts/mcp/headhunter-server.js:            text: 'Access token set successfully'
./backend/monolith/scripts/verify-ai-providers.js: * This script checks if AI provider API keys are properly configured
./backend/monolith/scripts/verify-ai-providers.js:// Check which providers have API keys configured
./backend/monolith/scripts/verify-ai-providers.js:  const isConfigured = !!apiKey && apiKey !== 'your-api-key-here' && apiKey.length > 10;
./backend/monolith/scripts/verify-ai-providers.js:  const keyPreview = isConfigured
./backend/monolith/scripts/verify-ai-providers.js:  console.log(`   Key: ${keyPreview}`);
./backend/monolith/scripts/verify-ai-providers.js:  console.log('‚ùå ERROR: No AI provider API keys configured!');
./backend/monolith/scripts/verify-ai-providers.js:  console.log('2. Add your API key(s) to the .env file');
./backend/monolith/scripts/verify-ai-providers.js:  console.log('\nRecommended: Get a Polza.ai API key from https://polza.ai');
./backend/monolith/scripts/verify-ai-providers.js:      const key = process.env[p.envKey];
./backend/monolith/scripts/verify-ai-providers.js:      return key && key !== 'your-api-key-here' && key.length > 10;
./backend/monolith/scripts/verify-ai-providers.js:console.log('- API keys should never be committed to git');
./backend/monolith/scripts/analyze-datanewton-fields.js:    const keys = Object.keys(obj)
./backend/monolith/scripts/analyze-datanewton-fields.js:    if (keys.length === 0) {
./backend/monolith/scripts/analyze-datanewton-fields.js:    for (const key of keys) {
./backend/monolith/scripts/analyze-datanewton-fields.js:      const newPrefix = prefix ? `${prefix}.${key}` : key
./backend/monolith/scripts/analyze-datanewton-fields.js:      extractPaths(obj[key], newPrefix, paths, depth + 1)
./backend/monolith/scripts/analyze-datanewton-fields.js:      params: { ...params, key: API_KEY },
./backend/monolith/scripts/create-test-user.js: * Creates a test user with login 'd' and password 'd' for development/testing
./backend/monolith/scripts/create-test-user.js:import { hashPassword } from '../src/services/user-sync/passwordSyncService.js';
./backend/monolith/scripts/create-test-user.js:    const passwordHash = await hashPassword('d');
./backend/monolith/scripts/create-test-user.js:      password_hash: passwordHash, // Store password hash for test user
./backend/monolith/scripts/create-test-user.js:    console.log('Password hash:', passwordHash);
./backend/monolith/scripts/create-new-parameters.js:  password: 'd',
./backend/monolith/scripts/create-new-parameters.js:  formData.append('pwd', INTEGRAM_CONFIG.password)
./backend/monolith/scripts/create-new-parameters.js:    token: response.data.token,
./backend/monolith/scripts/create-new-parameters.js:        'X-Authorization': auth.token
./backend/monolith/scripts/create-default-org-template.js:  password: process.env.INTEGRAM_PASSWORD || 'd'
./backend/monolith/scripts/create-default-org-template.js:        password: CONFIG.password
./backend/monolith/scripts/create-default-org-template.js:    console.log(`  - Settings: ${Object.keys(DEFAULT_TEMPLATE.settings).length}`);
./backend/monolith/scripts/get-table-metadata.js:        password: 'd'
./backend/monolith/scripts/create-chat-tables.js:  password: 'd'
./backend/monolith/scripts/create-chat-tables.js:    await client.authenticate(INTEGRAM_CONFIG.login, INTEGRAM_CONFIG.password)
./backend/monolith/scripts/compare-field-mappings.js:  const existingKeys = Object.keys(PARAM_ID_MAP_STATIC)
./backend/monolith/scripts/add-workspace-columns.js:        password: PASSWORD
./backend/monolith/scripts/create-workspace-tables.js:        password: PASSWORD
./backend/monolith/scripts/create-workspace-tables-final.js:      arguments: { serverURL: SERVER_URL, database: DATABASE, login: LOGIN, password: PASSWORD }
./backend/monolith/scripts/test-workspace-data-v2.js:      arguments: { serverURL: SERVER_URL, database: DATABASE, login: LOGIN, password: PASSWORD }
./backend/monolith/scripts/validate-manifests.js:          this.errors.push(`${file}: Missing 'agent' root key`)
./backend/monolith/scripts/test-organization-creation.js:        'X-Authorization': auth.token
./backend/monolith/scripts/test-organization-creation.js:      headers: { 'X-Authorization': auth.token }
./backend/monolith/scripts/create-db-sessions-table.js: * Issue #3631: Sistema de almacenamiento de tokens de bases de datos
./backend/monolith/scripts/create-db-sessions-table.js: * for storing authentication tokens across multiple databases.
./backend/monolith/scripts/create-db-sessions-table.js: * - Databases JSON (encrypted token data)
./backend/monolith/scripts/create-db-sessions-table.js:  console.log('Issue #3631: Sistema de almacenamiento de tokens de bases de datos\n');
./backend/monolith/scripts/create-db-sessions-table.js:        password: PASSWORD
./backend/monolith/scripts/setup-github-integration-table.js:  password: process.env.INTEGRAM_PASSWORD || 'd'
./backend/monolith/scripts/setup-github-integration-table.js:      options.headers['Cookie'] = `token=${sessionToken}`
./backend/monolith/scripts/setup-github-integration-table.js:    password: config.password
./backend/monolith/scripts/setup-github-integration-table.js:  // Extract session tokens from cookies
./backend/monolith/scripts/setup-github-integration-table.js:    if (cookie.startsWith('token=')) {
./backend/monolith/scripts/setup-github-integration-table.js:    throw new Error('Failed to obtain session tokens')
./backend/monolith/scripts/setup-github-integration-table.js:      { name: 'Token', type: REQ_TYPE_SHORT, description: 'GitHub access token (encrypted)' },
./backend/monolith/scripts/test-ai-connection.js:  if (!apiKey || apiKey === 'your-api-key-here' || apiKey.length < 10) {
./backend/monolith/scripts/test-ai-connection.js:        max_tokens: 50,
./backend/monolith/scripts/test-ai-connection.js:      console.log(`   Tokens: ${response.usage?.total_tokens || 'N/A'}`);
./backend/monolith/scripts/test-ai-connection.js:        tokens: response.usage
./backend/monolith/scripts/test-ai-connection.js:        max_tokens: 50,
./backend/monolith/scripts/test-ai-connection.js:      console.log(`   Tokens: input=${response.usage.input_tokens}, output=${response.usage.output_tokens}`);
./backend/monolith/scripts/test-ai-connection.js:        tokens: response.usage
./backend/monolith/scripts/test-ai-connection.js:    console.log(`\nAvailable providers: ${Object.keys(providers).join(', ')}`);
./backend/monolith/scripts/test-ai-connection.js:    for (const [key, config] of Object.entries(providers)) {
./backend/monolith/scripts/test-ai-connection.js:      const result = await testProvider(key, config);
./backend/monolith/scripts/test-ai-connection.js:    console.log('‚ùå All configured providers failed. Check API keys and network connection.');
./backend/monolith/scripts/test-ai-connection.js:    console.log('‚ö†Ô∏è  No providers configured. Please add API keys to .env file.');
./backend/monolith/scripts/setup-anthropic-key.js:// setup-anthropic-key.js - Setup script for Anthropic API key
./backend/monolith/scripts/setup-anthropic-key.js:// Usage: node scripts/setup-anthropic-key.js [API_KEY]
./backend/monolith/scripts/setup-anthropic-key.js:import aiProviderKeysService from '../src/services/ai-provider-keys/AIProviderKeysService.js';
./backend/monolith/scripts/setup-anthropic-key.js:  // Get API key from command line argument or prompt
./backend/monolith/scripts/setup-anthropic-key.js:    console.error('‚ùå Error: API key is required');
./backend/monolith/scripts/setup-anthropic-key.js:    console.log('  node scripts/setup-anthropic-key.js YOUR_ANTHROPIC_API_KEY');
./backend/monolith/scripts/setup-anthropic-key.js:    console.log('  node scripts/setup-anthropic-key.js sk-ant-api03-xxx...');
./backend/monolith/scripts/setup-anthropic-key.js:    console.log('Get your API key at: https://console.anthropic.com/');
./backend/monolith/scripts/setup-anthropic-key.js:  // Validate API key format
./backend/monolith/scripts/setup-anthropic-key.js:    console.warn('‚ö†Ô∏è  Warning: API key should start with "sk-ant-"');
./backend/monolith/scripts/setup-anthropic-key.js:    console.log('   Make sure you copied the correct key from Anthropic Console');
./backend/monolith/scripts/setup-anthropic-key.js:    console.log('üì¶ Setting up Anthropic API key...');
./backend/monolith/scripts/setup-anthropic-key.js:        keyName: 'default',
./backend/monolith/scripts/setup-anthropic-key.js:    console.log('‚úÖ Anthropic API key configured successfully!');
./backend/monolith/scripts/setup-anthropic-key.js:    console.log(`  Key Name: ${result.keyName}`);
./backend/monolith/scripts/setup-anthropic-key.js:    console.error('‚ùå Error setting up API key:', error.message);
./backend/monolith/scripts/generate-jwt-secret.js: * Generate strong JWT secret
./backend/monolith/scripts/generate-jwt-secret.js: * Usage: node scripts/generate-jwt-secret.js
./backend/monolith/scripts/generate-jwt-secret.js: * This script generates a cryptographically secure random secret
./backend/monolith/scripts/generate-jwt-secret.js:// Generate 256-bit (32 bytes) random secret
./backend/monolith/scripts/generate-jwt-secret.js:const secret = crypto.randomBytes(32).toString('hex')
./backend/monolith/scripts/generate-jwt-secret.js:console.log(secret)
./backend/monolith/scripts/generate-jwt-secret.js:console.log(`JWT_SECRET=${secret}`)
./backend/monolith/scripts/generate-jwt-secret.js:console.log('  1. Keep this secret safe and never commit it to git')
./backend/monolith/scripts/generate-jwt-secret.js:console.log('  2. Use different secrets for development and production')
./backend/monolith/scripts/generate-jwt-secret.js:console.log('  3. Rotate secrets regularly (every 3-6 months)')
./backend/monolith/scripts/generate-jwt-secret.js:console.log('  4. If compromised, generate a new secret immediately')
./backend/monolith/src/services/mcp/integram-sse-server.js:              password: {
./backend/monolith/src/services/mcp/integram-sse-server.js:                description: 'User password',
./backend/monolith/src/services/mcp/integram-sse-server.js:            required: ['serverURL', 'database', 'login', 'password'],
./backend/monolith/src/services/mcp/integram-sse-server.js:          description: 'Set authentication context from existing session (token and xsrf)',
./backend/monolith/src/services/mcp/integram-sse-server.js:              token: {
./backend/monolith/src/services/mcp/integram-sse-server.js:                description: 'Session token',
./backend/monolith/src/services/mcp/integram-sse-server.js:                description: 'XSRF token',
./backend/monolith/src/services/mcp/integram-sse-server.js:            required: ['serverURL', 'database', 'token', 'xsrfToken'],
./backend/monolith/src/services/mcp/integram-sse-server.js:                description: 'Requisites as key-value pairs (requisiteId: value)',
./backend/monolith/src/services/mcp/integram-sse-server.js:            args.password
./backend/monolith/src/services/mcp/integram-sse-server.js:          apiClient.setContext(args.token, args.xsrfToken);
./backend/monolith/src/services/mcp/integram-server.js:    this.token = null;
./backend/monolith/src/services/mcp/integram-server.js:    if (!this.token && endpoint !== 'xsrf') {
./backend/monolith/src/services/mcp/integram-server.js:    if (this.token) {
./backend/monolith/src/services/mcp/integram-server.js:      headers['X-Authorization'] = this.token;
./backend/monolith/src/services/mcp/integram-server.js:    if (!this.token) {
./backend/monolith/src/services/mcp/integram-server.js:    for (const [key, value] of Object.entries(data)) {
./backend/monolith/src/services/mcp/integram-server.js:        parts.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);
./backend/monolith/src/services/mcp/integram-server.js:      'X-Authorization': this.token
./backend/monolith/src/services/mcp/integram-server.js:  async authenticate(serverURL, database, login, password) {
./backend/monolith/src/services/mcp/integram-server.js:    formData.append('pwd', password);
./backend/monolith/src/services/mcp/integram-server.js:      throw new Error('Invalid login or password');
./backend/monolith/src/services/mcp/integram-server.js:    this.token = response.data.token;
./backend/monolith/src/services/mcp/integram-server.js:    this.token = sessionInfo.token;
./backend/monolith/src/services/mcp/integram-server.js:      token: this.token,
./backend/monolith/src/services/mcp/integram-server.js:  setContext(serverURL, database, token, xsrfToken) {
./backend/monolith/src/services/mcp/integram-server.js:    this.token = token;
./backend/monolith/src/services/mcp/integram-server.js:        password: {
./backend/monolith/src/services/mcp/integram-server.js:      required: ['serverURL', 'database', 'login', 'password']
./backend/monolith/src/services/mcp/integram-server.js:    description: 'Set authentication context from existing session (token and xsrf)',
./backend/monolith/src/services/mcp/integram-server.js:        token: {
./backend/monolith/src/services/mcp/integram-server.js:          description: 'Authentication token'
./backend/monolith/src/services/mcp/integram-server.js:          description: 'XSRF token'
./backend/monolith/src/services/mcp/integram-server.js:      required: ['serverURL', 'database', 'token', 'xsrfToken']
./backend/monolith/src/services/mcp/integram-server.js:    description: 'Create new object in Integram. Automatically sets up=1 for independent objects. For reference requisites (foreign keys), pass the target object ID as string value. The tool automatically applies requisites via _m_set after creation to ensure reference fields are saved correctly.',
./backend/monolith/src/services/mcp/integram-server.js:          description: 'Requisites as key-value pairs. Key is requisiteId (string), value is the field value. For reference fields, pass target object ID as string (e.g., {"197038": "197039"})',
./backend/monolith/src/services/mcp/integram-server.js:          description: 'Requisites as key-value pairs',
./backend/monolith/src/services/mcp/integram-server.js:          description: 'Requisites to set as key-value pairs. Key is requisiteId (string), value is the new value. For reference fields, pass target object ID as string (e.g., {"197038": "197039"})',
./backend/monolith/src/services/mcp/integram-server.js:          description: 'Array of objects to create. Each object has "value" (main field) and "requisites" (key-value pairs where key is requisiteId)',
./backend/monolith/src/services/mcp/integram-server.js:                description: 'Requisites as key-value pairs. Key is requisiteId (string), value is the field value.',
./backend/monolith/src/services/mcp/integram-server.js:          description: 'Requisites for the parent object (key=requisiteId, value=field value)',
./backend/monolith/src/services/mcp/integram-server.js:          args.password
./backend/monolith/src/services/mcp/integram-server.js:          args.token,
./backend/monolith/src/services/mcp/integram-server.js:          if (Object.keys(reportReqs).length > 0) {
./backend/monolith/src/services/mcp/integram-server.js:              if (Object.keys(fromReqs).length > 0 && fromId) {
./backend/monolith/src/services/mcp/integram-server.js:              if (Object.keys(colReqs).length > 0 && colId) {
./backend/monolith/src/services/mcp/integram-server.js:          if (Object.keys(colReqs).length > 0) {
./backend/monolith/src/services/mcp/integram-server.js:          if (Object.keys(fromReqs).length > 0) {
./backend/monolith/src/services/mcp/integram-server.js:          if (Object.keys(reportReqs).length > 0) {
./backend/monolith/src/services/mcp/integram-server.js:              if (Object.keys(fromReqs).length > 0) {
./backend/monolith/src/services/mcp/integram-server.js:              if (Object.keys(colReqs).length > 0) {
./backend/monolith/src/services/mcp/integram-server.js:                if (obj.requisites && Object.keys(obj.requisites).length > 0) {
./backend/monolith/src/services/mcp/integram-server.js:                  if (Object.keys(setData).length > 0) {
./backend/monolith/src/services/mcp/integram-server.js:          if (args.parentRequisites && Object.keys(args.parentRequisites).length > 0) {
./backend/monolith/src/services/mcp/integram-server.js:            if (Object.keys(setData).length > 0) {
./backend/monolith/src/services/mcp/integram-server.js:                if (child.requisites && Object.keys(child.requisites).length > 0) {
./backend/monolith/src/services/mcp/integram-server.js:                  if (Object.keys(setData).length > 0) {
./backend/monolith/src/services/mcp/integram-server.js:                if (Object.keys(fromReqs).length > 0) {
./backend/monolith/src/services/mcp/integram-server.js:                if (Object.keys(colReqs).length > 0) {
./backend/monolith/src/services/mcp/integram-server.js:                headers = Object.keys(data[0]);
./backend/monolith/src/services/mcp/integram-server.js:            // Simple keyword matching
./backend/monolith/src/services/mcp/integram-server.js:            const keywords = {
./backend/monolith/src/services/mcp/integram-server.js:            for (const [keyword, tableName] of Object.entries(keywords)) {
./backend/monolith/src/services/mcp/integram-server.js:              if (question.includes(keyword)) {
./backend/monolith/src/services/mcp/integram-server.js:                headers = Object.keys(data[0]);
./backend/monolith/src/services/auth/sessionService.js: * @returns {Promise<Object>} Session with tokens
./backend/monolith/src/services/auth/sessionService.js:    `INSERT INTO sessions (user_id, access_token_hash, refresh_token_hash, ip_address, user_agent, expires_at, refresh_expires_at, metadata)
./backend/monolith/src/services/auth/sessionService.js:    tokenType: 'Bearer',
./backend/monolith/src/services/auth/sessionService.js: * Find session by access token hash
./backend/monolith/src/services/auth/sessionService.js: * @param {string} accessToken - Access token (unhashed)
./backend/monolith/src/services/auth/sessionService.js:  const tokenHash = hashToken(accessToken)
./backend/monolith/src/services/auth/sessionService.js:     WHERE access_token_hash = $1
./backend/monolith/src/services/auth/sessionService.js:    [tokenHash]
./backend/monolith/src/services/auth/sessionService.js: * Find session by refresh token hash
./backend/monolith/src/services/auth/sessionService.js: * @param {string} refreshToken - Refresh token (unhashed)
./backend/monolith/src/services/auth/sessionService.js:  const tokenHash = hashToken(refreshToken)
./backend/monolith/src/services/auth/sessionService.js:     WHERE refresh_token_hash = $1
./backend/monolith/src/services/auth/sessionService.js:    [tokenHash]
./backend/monolith/src/services/auth/sessionService.js: * Refresh session tokens
./backend/monolith/src/services/auth/sessionService.js: * @param {string} refreshToken - Current refresh token
./backend/monolith/src/services/auth/sessionService.js: * @returns {Promise<Object>} New tokens
./backend/monolith/src/services/auth/sessionService.js:    throw new Error('Invalid or expired refresh token')
./backend/monolith/src/services/auth/sessionService.js:  // Generate new token pair
./backend/monolith/src/services/auth/sessionService.js:  // Update session with new tokens
./backend/monolith/src/services/auth/sessionService.js:     SET access_token_hash = $1,
./backend/monolith/src/services/auth/sessionService.js:         refresh_token_hash = $2,
./backend/monolith/src/services/auth/sessionService.js:    tokenType: 'Bearer',
./backend/monolith/src/services/auth/sessionService.js: * @param {string} accessToken - Access token
./backend/monolith/src/services/auth/sessionService.js:  const tokenHash = hashToken(accessToken)
./backend/monolith/src/services/auth/sessionService.js:    'UPDATE sessions SET is_active = false WHERE access_token_hash = $1',
./backend/monolith/src/services/auth/sessionService.js:    [tokenHash]
./backend/monolith/src/services/auth/sessionService.js:  logger.info({ tokenHash: tokenHash.substring(0, 10) }, 'Session invalidated')
./backend/monolith/src/services/auth/oauthService.js: * Exchange authorization code for access token (Yandex)
./backend/monolith/src/services/auth/oauthService.js:  // Exchange code for token
./backend/monolith/src/services/auth/oauthService.js:  const tokenResponse = await axios.post(
./backend/monolith/src/services/auth/oauthService.js:    'https://oauth.yandex.ru/token',
./backend/monolith/src/services/auth/oauthService.js:      client_secret: clientSecret,
./backend/monolith/src/services/auth/oauthService.js:  const accessToken = tokenResponse.data.access_token
./backend/monolith/src/services/auth/oauthService.js: * Exchange authorization code for access token (VKontakte)
./backend/monolith/src/services/auth/oauthService.js:  // Exchange code for token
./backend/monolith/src/services/auth/oauthService.js:  const tokenResponse = await axios.get('https://oauth.vk.com/access_token', {
./backend/monolith/src/services/auth/oauthService.js:      client_secret: clientSecret,
./backend/monolith/src/services/auth/oauthService.js:  const { access_token: accessToken, user_id: userId, email } = tokenResponse.data
./backend/monolith/src/services/auth/oauthService.js:      access_token: accessToken,
./backend/monolith/src/services/auth/oauthService.js:  const dataCheckString = Object.keys(authData)
./backend/monolith/src/services/auth/oauthService.js:    .map((key) => `${key}=${authData[key]}`)
./backend/monolith/src/services/auth/oauthService.js:  const secretKey = crypto.createHash('sha256').update(botToken).digest()
./backend/monolith/src/services/auth/oauthService.js:  const hash = crypto.createHmac('sha256', secretKey).update(dataCheckString).digest('hex')
./backend/monolith/src/services/auth/oauthService.js: * Exchange authorization code for access token (Google)
./backend/monolith/src/services/auth/oauthService.js:  // Exchange code for token
./backend/monolith/src/services/auth/oauthService.js:  const tokenResponse = await axios.post('https://oauth2.googleapis.com/token', {
./backend/monolith/src/services/auth/oauthService.js:    client_secret: clientSecret,
./backend/monolith/src/services/auth/oauthService.js:  const accessToken = tokenResponse.data.access_token
./backend/monolith/src/services/auth/userService.js:import { hashPassword } from '../../utils/auth/password.js'
./backend/monolith/src/services/auth/userService.js:  for (const [key, value] of Object.entries(updates)) {
./backend/monolith/src/services/auth/userService.js:    const snakeKey = key.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`)
./backend/monolith/src/services/auth/userService.js:  logger.info({ userId, updates: Object.keys(updates) }, 'User updated')
./backend/monolith/src/services/auth/authMethodService.js:import { hashPassword, comparePassword } from '../../utils/auth/password.js'
./backend/monolith/src/services/auth/authMethodService.js:  const { authType, provider, providerUserId, password, isPrimary, metadata } = authData
./backend/monolith/src/services/auth/authMethodService.js:  let passwordHash = null
./backend/monolith/src/services/auth/authMethodService.js:  if (password) {
./backend/monolith/src/services/auth/authMethodService.js:    passwordHash = await hashPassword(password)
./backend/monolith/src/services/auth/authMethodService.js:    `INSERT INTO auth_methods (user_id, auth_type, provider, provider_user_id, password_hash, is_primary, metadata)
./backend/monolith/src/services/auth/authMethodService.js:      passwordHash,
./backend/monolith/src/services/auth/authMethodService.js: * Find password auth method for user by email/phone/username
./backend/monolith/src/services/auth/authMethodService.js:    `SELECT u.*, am.password_hash, am.id as auth_method_id
./backend/monolith/src/services/auth/authMethodService.js:       AND am.auth_type IN ('email_password', 'phone_password')
./backend/monolith/src/services/auth/authMethodService.js: * Verify password for auth method
./backend/monolith/src/services/auth/authMethodService.js: * @param {string} password - Password to verify
./backend/monolith/src/services/auth/authMethodService.js: * @returns {Promise<boolean>} True if password is correct
./backend/monolith/src/services/auth/authMethodService.js:export async function verifyPassword(authMethodId, password) {
./backend/monolith/src/services/auth/authMethodService.js:    'SELECT password_hash FROM auth_methods WHERE id = $1',
./backend/monolith/src/services/auth/authMethodService.js:  return await comparePassword(password, result.rows[0].password_hash)
./backend/monolith/src/services/auth/authMethodService.js: * Update password for auth method
./backend/monolith/src/services/auth/authMethodService.js: * @param {string} newPassword - New password
./backend/monolith/src/services/auth/authMethodService.js:  const passwordHash = await hashPassword(newPassword)
./backend/monolith/src/services/auth/authMethodService.js:     SET password_hash = $1, updated_at = CURRENT_TIMESTAMP
./backend/monolith/src/services/auth/authMethodService.js:     WHERE user_id = $2 AND auth_type IN ('email_password', 'phone_password')`,
./backend/monolith/src/services/auth/authMethodService.js:    [passwordHash, userId]
./backend/monolith/src/services/integram/IntegramDatabaseService.js:    for (const tableName of Object.keys(SYSTEM_TABLES)) {
./backend/monolith/src/services/integram/IntegramDatabaseService.js:      systemTables: Object.keys(SYSTEM_TABLES),
./backend/monolith/src/services/integram/IntegramDatabaseService.js:    for (const [key, value] of Object.entries(filter)) {
./backend/monolith/src/services/integram/IntegramDatabaseService.js:      results = results.filter(row => row[key] === value)
./backend/monolith/src/services/integram/__tests__/IntegramDatabaseService.test.js:        { name: 'config', schema: { key: { type: 'string' } } }
./backend/monolith/src/services/integram/integram-client.js: * - References: Foreign keys, lookup tables
./backend/monolith/src/services/integram/integram-client.js:    this.token = null
./backend/monolith/src/services/integram/integram-client.js:   * Set authentication tokens directly
./backend/monolith/src/services/integram/integram-client.js:   * @param {string} token - Authentication token
./backend/monolith/src/services/integram/integram-client.js:   * @param {string} xsrf - XSRF token
./backend/monolith/src/services/integram/integram-client.js:  setAuth(token, xsrf, userId = null) {
./backend/monolith/src/services/integram/integram-client.js:    this.token = token
./backend/monolith/src/services/integram/integram-client.js:   * @returns {Object} Auth info with token and xsrf
./backend/monolith/src/services/integram/integram-client.js:      token: this.token,
./backend/monolith/src/services/integram/integram-client.js:    if (!this.token && endpoint !== 'xsrf') {
./backend/monolith/src/services/integram/integram-client.js:    if (this.token) {
./backend/monolith/src/services/integram/integram-client.js:      headers['X-Authorization'] = this.token
./backend/monolith/src/services/integram/integram-client.js:    if (!this.token) {
./backend/monolith/src/services/integram/integram-client.js:    // Add XSRF token to form data
./backend/monolith/src/services/integram/integram-client.js:    for (const [key, value] of Object.entries(data)) {
./backend/monolith/src/services/integram/integram-client.js:        postData.append(key, value)
./backend/monolith/src/services/integram/integram-client.js:      'X-Authorization': this.token
./backend/monolith/src/services/integram/integram-client.js:   * Authenticate with username and password
./backend/monolith/src/services/integram/integram-client.js:   * @param {string} password - Password
./backend/monolith/src/services/integram/integram-client.js:  async authenticate(login, password) {
./backend/monolith/src/services/integram/integram-client.js:    formData.append('pwd', password)
./backend/monolith/src/services/integram/integram-client.js:    this.token = response.data.token
./backend/monolith/src/services/integram/integram-client.js:        headers: { 'X-Authorization': this.token }
./backend/monolith/src/services/integram/integram-client.js:      this.token = sessionResponse.data.token || this.token
./backend/monolith/src/services/integram/integram-client.js:   * Add reference column to type (creates foreign key to another table)
./backend/monolith/src/services/integram/integram-client.js:      if (result && result.id && Object.keys(requisites).length > 0) {
./backend/monolith/src/services/integram/OrbityDatabaseSetupService.js:  async initialize(login, password) {
./backend/monolith/src/services/integram/OrbityDatabaseSetupService.js:      const authResult = await this.client.auth(login, password)
./backend/monolith/src/services/integram/OrbityDatabaseSetupService.js:        createdTypes: Object.keys(this.createdTypes).length,
./backend/monolith/src/services/chat/chatService.js:   * @param {string} password - Password
./backend/monolith/src/services/chat/chatService.js:  async initialize(login, password) {
./backend/monolith/src/services/chat/chatService.js:      await this.client.authenticate(login, password)
./backend/monolith/src/services/chat/chatService.js:   * Set authentication tokens directly (for reusing existing session)
./backend/monolith/src/services/chat/chatService.js:   * @param {string} token - Auth token
./backend/monolith/src/services/chat/chatService.js:   * @param {string} xsrf - XSRF token
./backend/monolith/src/services/chat/chatService.js:  setAuth(token, xsrf) {
./backend/monolith/src/services/chat/chatService.js:    this.client.setAuth(token, xsrf)
./backend/monolith/src/api/routes/unified-auth.js: * - GET /api/unified-auth/tokens/:sessionId - Get all tokens from session
./backend/monolith/src/api/routes/unified-auth.js: * - GET /api/unified-auth/token/:sessionId/:database - Get token for specific database
./backend/monolith/src/api/routes/unified-auth.js: * - POST /api/unified-auth/renew-tokens - Manually renew all tokens (Issue #3556)
./backend/monolith/src/api/routes/unified-auth.js:  logger.warn({ error: error.message }, 'Database token storage not available, using in-memory only');
./backend/monolith/src/api/routes/unified-auth.js: * - password: string (required if not using SSO)
./backend/monolith/src/api/routes/unified-auth.js: * - ssoToken: string (optional) - SSO access token
./backend/monolith/src/api/routes/unified-auth.js: * - session: object with sessionId and tokens for all databases
./backend/monolith/src/api/routes/unified-auth.js:    const { username, password, databases, mfaCode, ssoProvider, ssoToken } = req.body;
./backend/monolith/src/api/routes/unified-auth.js:    if (!username || !password) {
./backend/monolith/src/api/routes/unified-auth.js:        error: 'Username and password are required (or use SSO)'
./backend/monolith/src/api/routes/unified-auth.js:    const result = await unifiedAuthService.authenticateUnified(username, password, {
./backend/monolith/src/api/routes/unified-auth.js: * GET /api/unified-auth/tokens/:sessionId
./backend/monolith/src/api/routes/unified-auth.js: * Get all tokens from session
./backend/monolith/src/api/routes/unified-auth.js: * - Object mapping database names to token data
./backend/monolith/src/api/routes/unified-auth.js:router.get('/tokens/:sessionId', async (req, res) => {
./backend/monolith/src/api/routes/unified-auth.js:    logger.info({ sessionId }, 'Get all tokens request');
./backend/monolith/src/api/routes/unified-auth.js:    const tokens = await unifiedAuthService.getAllTokens(sessionId);
./backend/monolith/src/api/routes/unified-auth.js:    if (Object.keys(tokens).length === 0) {
./backend/monolith/src/api/routes/unified-auth.js:      tokens
./backend/monolith/src/api/routes/unified-auth.js:    logger.error({ error: error.message }, 'Get tokens error');
./backend/monolith/src/api/routes/unified-auth.js: * GET /api/unified-auth/token/:sessionId/:database
./backend/monolith/src/api/routes/unified-auth.js: * Get token for specific database
./backend/monolith/src/api/routes/unified-auth.js:router.get('/token/:sessionId/:database', async (req, res) => {
./backend/monolith/src/api/routes/unified-auth.js:    logger.info({ sessionId, database }, 'Get database token request');
./backend/monolith/src/api/routes/unified-auth.js:      token: dbAuth.token,
./backend/monolith/src/api/routes/unified-auth.js:    logger.error({ error: error.message }, 'Get database token error');
./backend/monolith/src/api/routes/unified-auth.js: * GET /api/unified-auth/my-token/:sessionId
./backend/monolith/src/api/routes/unified-auth.js: * Get 'my' database token for cross-database access (Issue #3811)
./backend/monolith/src/api/routes/unified-auth.js: * This endpoint returns the 'my' database token which can be used
./backend/monolith/src/api/routes/unified-auth.js:router.get('/my-token/:sessionId', async (req, res) => {
./backend/monolith/src/api/routes/unified-auth.js:    logger.info({ sessionId }, 'Get my database token request');
./backend/monolith/src/api/routes/unified-auth.js:        error: 'My database token not found or session expired'
./backend/monolith/src/api/routes/unified-auth.js:      token: myDbAuth.token,
./backend/monolith/src/api/routes/unified-auth.js:      usage: 'Use this token with "my: {token}" header for cross-database access'
./backend/monolith/src/api/routes/unified-auth.js:    logger.error({ error: error.message }, 'Get my database token error');
./backend/monolith/src/api/routes/unified-auth.js: * - password: string (required)
./backend/monolith/src/api/routes/unified-auth.js: * - Refresh result with new token
./backend/monolith/src/api/routes/unified-auth.js:    const { sessionId, database, password } = req.body;
./backend/monolith/src/api/routes/unified-auth.js:    if (!sessionId || !database || !password) {
./backend/monolith/src/api/routes/unified-auth.js:        error: 'SessionId, database, and password are required'
./backend/monolith/src/api/routes/unified-auth.js:    const result = await unifiedAuthService.refreshDatabaseAuth(sessionId, database, password);
./backend/monolith/src/api/routes/unified-auth.js: * POST /api/unified-auth/renew-tokens
./backend/monolith/src/api/routes/unified-auth.js: * Manually renew all tokens in a session (Issue #3556)
./backend/monolith/src/api/routes/unified-auth.js: * - password: string (required)
./backend/monolith/src/api/routes/unified-auth.js:router.post('/renew-tokens', async (req, res) => {
./backend/monolith/src/api/routes/unified-auth.js:    const { sessionId, username, password } = req.body;
./backend/monolith/src/api/routes/unified-auth.js:    if (!sessionId || !username || !password) {
./backend/monolith/src/api/routes/unified-auth.js:        error: 'SessionId, username, and password are required'
./backend/monolith/src/api/routes/unified-auth.js:    logger.info({ sessionId }, 'Manual token renewal request');
./backend/monolith/src/api/routes/unified-auth.js:    const result = await unifiedAuthService.renewAllTokens(sessionId, username, password);
./backend/monolith/src/api/routes/unified-auth.js: *   - tokenUrl: string
./backend/monolith/src/api/routes/unified-auth.js:    const requiredFields = ['clientId', 'clientSecret', 'redirectUri', 'authorizationUrl', 'tokenUrl', 'userInfoUrl'];
./backend/monolith/src/api/routes/unified-auth.js: * - state: string (required) - CSRF state token
./backend/monolith/src/api/routes/unified-auth.js:        error: 'Provider and SSO token are required'
./backend/monolith/src/api/routes/drondoc-agents-integram.js:        password: 'd'
./backend/monolith/src/api/routes/drondoc-agents-integram.js:        password: 'd'
./backend/monolith/src/api/routes/drondoc-agents-integram.js:        updates: Object.keys(updates)
./backend/monolith/src/api/routes/drondoc-agents-integram.js:        password: 'd'
./backend/monolith/src/api/routes/drondoc-agents-integram.js:        password: 'd'
./backend/monolith/src/api/routes/email-auth.js: * Handles email-based user registration, verification, and password reset.
./backend/monolith/src/api/routes/email-auth.js: * - POST /api/email-auth/password-reset-request - Request password reset
./backend/monolith/src/api/routes/email-auth.js: * - POST /api/email-auth/password-reset - Reset password with token
./backend/monolith/src/api/routes/email-auth.js: * - password: string (required, min 8 chars)
./backend/monolith/src/api/routes/email-auth.js:    const { email, password, username, displayName, referralCode } = req.body;
./backend/monolith/src/api/routes/email-auth.js:    if (!password) {
./backend/monolith/src/api/routes/email-auth.js:      password,
./backend/monolith/src/api/routes/email-auth.js: * - password: string (required)
./backend/monolith/src/api/routes/email-auth.js:    const { email, password, username, displayName, database = 'my' } = req.body;
./backend/monolith/src/api/routes/email-auth.js:    if (!password) {
./backend/monolith/src/api/routes/email-auth.js:    if (password.length < 8) {
./backend/monolith/src/api/routes/email-auth.js:    // Get token and xsrf from auth response
./backend/monolith/src/api/routes/email-auth.js:    const token = authResponse.data.token;
./backend/monolith/src/api/routes/email-auth.js:      token: token,
./backend/monolith/src/api/routes/email-auth.js:    // IMPORTANT: Send plain password to Integram - it handles hashing internally
./backend/monolith/src/api/routes/email-auth.js:        'X-Authorization': token
./backend/monolith/src/api/routes/email-auth.js:    // Step 3: Set user requisites (email, password, name)
./backend/monolith/src/api/routes/email-auth.js:    // - 20: Password (PWD) - Send PLAIN password, Integram hashes it internally!
./backend/monolith/src/api/routes/email-auth.js:    // IMPORTANT: Send PLAIN password - Integram handles MD5 hashing internally
./backend/monolith/src/api/routes/email-auth.js:    // Do NOT hash with MD5 or bcrypt - just send the plain text password
./backend/monolith/src/api/routes/email-auth.js:    saveData.append(`t${pwdReqId}`, password); // Send PLAIN password!
./backend/monolith/src/api/routes/email-auth.js:    }, 'Sending password to Integram _m_save');
./backend/monolith/src/api/routes/email-auth.js:        'X-Authorization': token
./backend/monolith/src/api/routes/email-auth.js:    // Create welcome token for new user (async, non-blocking)
./backend/monolith/src/api/routes/email-auth.js:    defaultTokenService.ensureDefaultToken(userId, token)
./backend/monolith/src/api/routes/email-auth.js:      .then(tokenResult => {
./backend/monolith/src/api/routes/email-auth.js:        if (tokenResult.success) {
./backend/monolith/src/api/routes/email-auth.js:          logger.info({ userId, email, tokenId: tokenResult.tokenId }, 'Welcome token created');
./backend/monolith/src/api/routes/email-auth.js:          logger.warn({ userId, email, error: tokenResult.error }, 'Failed to create welcome token');
./backend/monolith/src/api/routes/email-auth.js:        logger.error({ userId, email, error: err.message }, 'Error creating welcome token');
./backend/monolith/src/api/routes/email-auth.js: * - token: string (required)
./backend/monolith/src/api/routes/email-auth.js:    const { token, databases } = req.body;
./backend/monolith/src/api/routes/email-auth.js:    if (!token) {
./backend/monolith/src/api/routes/email-auth.js:        error: 'Verification token is required'
./backend/monolith/src/api/routes/email-auth.js:    logger.info({ token: token.substring(0, 10) + '...' }, 'Email verification request');
./backend/monolith/src/api/routes/email-auth.js:    const result = await verifyEmail(token, databases);
./backend/monolith/src/api/routes/email-auth.js: * - password: string (required)
./backend/monolith/src/api/routes/email-auth.js:    const { email, password, username, displayName } = req.body;
./backend/monolith/src/api/routes/email-auth.js:    if (!email || !password) {
./backend/monolith/src/api/routes/email-auth.js:        error: 'Email and password are required'
./backend/monolith/src/api/routes/email-auth.js:      password,
./backend/monolith/src/api/routes/email-auth.js: * POST /api/email-auth/password-reset-request
./backend/monolith/src/api/routes/email-auth.js: * Request password reset email
./backend/monolith/src/api/routes/email-auth.js:router.post('/password-reset-request', async (req, res) => {
./backend/monolith/src/api/routes/email-auth.js:    // Send password reset email
./backend/monolith/src/api/routes/email-auth.js:      message: 'If an account with that email exists, we have sent a password reset link.',
./backend/monolith/src/api/routes/email-auth.js:      message: 'If an account with that email exists, we have sent a password reset link.'
./backend/monolith/src/api/routes/email-auth.js: * POST /api/email-auth/password-reset
./backend/monolith/src/api/routes/email-auth.js: * Reset password using token
./backend/monolith/src/api/routes/email-auth.js: * - token: string (required)
./backend/monolith/src/api/routes/email-auth.js:router.post('/password-reset', async (req, res) => {
./backend/monolith/src/api/routes/email-auth.js:    const { token, newPassword } = req.body;
./backend/monolith/src/api/routes/email-auth.js:    if (!token) {
./backend/monolith/src/api/routes/email-auth.js:        error: 'Reset token is required'
./backend/monolith/src/api/routes/email-auth.js:        error: 'New password is required'
./backend/monolith/src/api/routes/email-auth.js:    logger.info({ token: token.substring(0, 10) + '...' }, 'Password reset');
./backend/monolith/src/api/routes/email-auth.js:    // Reset password
./backend/monolith/src/api/routes/email-auth.js:    const result = await resetPassword(token, newPassword);
./backend/monolith/src/api/routes/email-auth.js:      message: 'Password reset successfully. You can now login with your new password.',
./backend/monolith/src/api/routes/email-auth.js: * GET /api/email-auth/verify-reset-token
./backend/monolith/src/api/routes/email-auth.js: * Verify password reset token (without resetting)
./backend/monolith/src/api/routes/email-auth.js: * - token: string (required)
./backend/monolith/src/api/routes/email-auth.js:router.get('/verify-reset-token', async (req, res) => {
./backend/monolith/src/api/routes/email-auth.js:    const { token } = req.query;
./backend/monolith/src/api/routes/email-auth.js:    if (!token) {
./backend/monolith/src/api/routes/email-auth.js:        error: 'Reset token is required'
./backend/monolith/src/api/routes/email-auth.js:    logger.info({ token: token.substring(0, 10) + '...' }, 'Verify reset token');
./backend/monolith/src/api/routes/email-auth.js:    // Verify token
./backend/monolith/src/api/routes/email-auth.js:    const result = await verifyPasswordResetToken(token);
./backend/monolith/src/api/routes/email-auth.js: * Request magic link for passwordless login
./backend/monolith/src/api/routes/email-auth.js: * Login using magic link token
./backend/monolith/src/api/routes/email-auth.js: * - token: string (required)
./backend/monolith/src/api/routes/email-auth.js:    const { token } = req.body;
./backend/monolith/src/api/routes/email-auth.js:    if (!token) {
./backend/monolith/src/api/routes/email-auth.js:        error: 'Magic link token is required'
./backend/monolith/src/api/routes/email-auth.js:    logger.info({ token: token.substring(0, 10) + '...' }, 'Magic login');
./backend/monolith/src/api/routes/email-auth.js:    const result = await verifyMagicLink(token);
./backend/monolith/src/api/routes/email-auth.js:    // TODO: Create session/JWT token for the user
./backend/monolith/src/api/routes/email-auth.js:      // TODO: Add session token or JWT here
./backend/monolith/src/api/routes/general-chat.js:    // Get Integram token from X-Authorization header (same as Profile.vue)
./backend/monolith/src/api/routes/general-chat.js:      // Get XSRF token and userId from /xsrf endpoint
./backend/monolith/src/api/routes/general-chat.js:        throw new Error('Failed to validate Integram token')
./backend/monolith/src/api/routes/general-chat.js:        error: 'Not authenticated. Please provide Integram token in X-Authorization header'
./backend/monolith/src/api/routes/auth.js:import { validatePasswordStrength } from '../../utils/auth/password.js'
./backend/monolith/src/api/routes/auth.js:import { authLimiter, registerLimiter, passwordResetLimiter, verificationLimiter } from '../../middleware/security/rateLimiter.js'
./backend/monolith/src/api/routes/auth.js: * Register with email and password
./backend/monolith/src/api/routes/auth.js:    body('password').isLength({ min: 8 }).withMessage('–ü–∞—Ä–æ–ª—å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∏–Ω–∏–º—É–º 8 —Å–∏–º–≤–æ–ª–æ–≤'),
./backend/monolith/src/api/routes/auth.js:      const { email, password, username, displayName } = req.body
./backend/monolith/src/api/routes/auth.js:      // Validate password strength
./backend/monolith/src/api/routes/auth.js:      const passwordValidation = validatePasswordStrength(password)
./backend/monolith/src/api/routes/auth.js:      if (!passwordValidation.isValid) {
./backend/monolith/src/api/routes/auth.js:          errors: passwordValidation.errors,
./backend/monolith/src/api/routes/auth.js:      // Create password auth method
./backend/monolith/src/api/routes/auth.js:        authType: 'email_password',
./backend/monolith/src/api/routes/auth.js:        password,
./backend/monolith/src/api/routes/auth.js:      const tokens = await sessionService.createSession(user, {
./backend/monolith/src/api/routes/auth.js:      // Issue #5025: Create default AI token for new user (1M tokens welcome bonus)
./backend/monolith/src/api/routes/auth.js:      // This is done asynchronously and non-blocking - registration succeeds even if token creation fails
./backend/monolith/src/api/routes/auth.js:      defaultTokenService.ensureDefaultToken(user.id, tokens.accessToken).catch(error => {
./backend/monolith/src/api/routes/auth.js:        logger.error('Failed to create default AI token for new user', {
./backend/monolith/src/api/routes/auth.js:        // Don't fail registration if token creation fails
./backend/monolith/src/api/routes/auth.js:      logAuthSuccess(user, 'email_password', req.ip)
./backend/monolith/src/api/routes/auth.js:          ...tokens,
./backend/monolith/src/api/routes/auth.js: * Register with phone and password
./backend/monolith/src/api/routes/auth.js:    body('password').isLength({ min: 8 }).withMessage('–ü–∞—Ä–æ–ª—å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∏–Ω–∏–º—É–º 8 —Å–∏–º–≤–æ–ª–æ–≤'),
./backend/monolith/src/api/routes/auth.js:      const { phone, password, displayName } = req.body
./backend/monolith/src/api/routes/auth.js:      // Validate password strength
./backend/monolith/src/api/routes/auth.js:      const passwordValidation = validatePasswordStrength(password)
./backend/monolith/src/api/routes/auth.js:      if (!passwordValidation.isValid) {
./backend/monolith/src/api/routes/auth.js:          errors: passwordValidation.errors,
./backend/monolith/src/api/routes/auth.js:      // Create password auth method
./backend/monolith/src/api/routes/auth.js:        authType: 'phone_password',
./backend/monolith/src/api/routes/auth.js:        password,
./backend/monolith/src/api/routes/auth.js:      const tokens = await sessionService.createSession(user, {
./backend/monolith/src/api/routes/auth.js:      // Issue #5025: Create default AI token for new user (1M tokens welcome bonus)
./backend/monolith/src/api/routes/auth.js:      // This is done asynchronously and non-blocking - registration succeeds even if token creation fails
./backend/monolith/src/api/routes/auth.js:      defaultTokenService.ensureDefaultToken(user.id, tokens.accessToken).catch(error => {
./backend/monolith/src/api/routes/auth.js:        logger.error('Failed to create default AI token for new user', {
./backend/monolith/src/api/routes/auth.js:        // Don't fail registration if token creation fails
./backend/monolith/src/api/routes/auth.js:      logAuthSuccess(user, 'phone_password', req.ip)
./backend/monolith/src/api/routes/auth.js:          ...tokens,
./backend/monolith/src/api/routes/auth.js: * Login with email/username/phone and password
./backend/monolith/src/api/routes/auth.js:    body('password').notEmpty().withMessage('–£–∫–∞–∂–∏—Ç–µ –ø–∞—Ä–æ–ª—å'),
./backend/monolith/src/api/routes/auth.js:      const { identifier, password } = req.body
./backend/monolith/src/api/routes/auth.js:      // Find user with password auth method
./backend/monolith/src/api/routes/auth.js:      // Verify password
./backend/monolith/src/api/routes/auth.js:        password
./backend/monolith/src/api/routes/auth.js:        logAuthFailure(identifier, 'invalid_password', req.ip)
./backend/monolith/src/api/routes/auth.js:      const tokens = await sessionService.createSession(authData, {
./backend/monolith/src/api/routes/auth.js:      logAuthSuccess(authData, 'password', req.ip)
./backend/monolith/src/api/routes/auth.js:          ...tokens,
./backend/monolith/src/api/routes/auth.js: * Refresh access token
./backend/monolith/src/api/routes/auth.js:        error: 'Refresh token is required',
./backend/monolith/src/api/routes/auth.js:    // Find session by refresh token
./backend/monolith/src/api/routes/auth.js:        error: 'Invalid or expired refresh token',
./backend/monolith/src/api/routes/auth.js:    const tokens = await sessionService.refreshSession(refreshToken, user)
./backend/monolith/src/api/routes/auth.js:      data: tokens,
./backend/monolith/src/api/routes/auth.js:      error: error.message || 'Failed to refresh token',
./backend/monolith/src/api/routes/integram-organizations.js:  const token = req.cookies?.token || req.headers['x-integram-token']
./backend/monolith/src/api/routes/integram-organizations.js:  if (!token || !xsrf) {
./backend/monolith/src/api/routes/integram-organizations.js:  client.setAuth(token, xsrf)
./backend/monolith/src/api/routes/oauth.js:  password: 20,        // id=20, orig=19, type=6 (PASSWORD_FIELD)
./backend/monolith/src/api/routes/oauth.js:  token: 125,          // id=125, orig=122, type=6 (PASSWORD_FIELD) - for legacy auth
./backend/monolith/src/api/routes/oauth.js:// Salt for generating XSRF tokens (must match legacy PHP SALT constant)
./backend/monolith/src/api/routes/oauth.js: * Generate XSRF token (matches legacy PHP xsrf() function)
./backend/monolith/src/api/routes/oauth.js: * @param {string} token - The access token
./backend/monolith/src/api/routes/oauth.js: * @returns {string} XSRF token (22 characters)
./backend/monolith/src/api/routes/oauth.js:function generateIntegramXsrf(token, database) {
./backend/monolith/src/api/routes/oauth.js:  // Salt($token, $database) = SALT + uppercase(token) + database + database
./backend/monolith/src/api/routes/oauth.js:  // Note: In PHP, first arg is $u (user), second is $val, but here we use token as identifier
./backend/monolith/src/api/routes/oauth.js:  const salted = `${INTEGRAM_SALT}${token.toUpperCase()}${database}${database}`
./backend/monolith/src/api/routes/oauth.js:  // Generate XSRF like PHP: substr(sha1(Salt($token, $z)), 0, 22)
./backend/monolith/src/api/routes/oauth.js:  // For xsrf($token, $z): Salt($token, $z) = SALT + uppercase($token) + $z + $z
./backend/monolith/src/api/routes/oauth.js:    tokenLength: integramToken.length,
./backend/monolith/src/api/routes/oauth.js:  const key = `${provider}_${providerUserId}`
./backend/monolith/src/api/routes/oauth.js:  return oauthBlacklist.has(key)
./backend/monolith/src/api/routes/oauth.js:  const key = `${provider}_${providerUserId}`
./backend/monolith/src/api/routes/oauth.js:  oauthBlacklist.set(key, { reason, timestamp: Date.now() })
./backend/monolith/src/api/routes/oauth.js:          'X-Authorization': client.session.token,
./backend/monolith/src/api/routes/oauth.js:          'X-Authorization': client.session.token,
./backend/monolith/src/api/routes/oauth.js:          'X-Authorization': client.session.token,
./backend/monolith/src/api/routes/oauth.js:    let integramToken = existingUser.reqs?.[OAUTH_FIELDS.token] || null
./backend/monolith/src/api/routes/oauth.js:      setData.append(`t${OAUTH_FIELDS.token}`, integramToken)
./backend/monolith/src/api/routes/oauth.js:            'X-Authorization': client.session.token,
./backend/monolith/src/api/routes/oauth.js:        'X-Authorization': client.session.token,
./backend/monolith/src/api/routes/oauth.js:  // No password needed for OAuth users - they authenticate via provider
./backend/monolith/src/api/routes/oauth.js:  requisites[OAUTH_FIELDS.token] = integramToken
./backend/monolith/src/api/routes/oauth.js:      requisitesKeys: Object.keys(requisites),
./backend/monolith/src/api/routes/oauth.js:      tokenFieldId: OAUTH_FIELDS.token,
./backend/monolith/src/api/routes/oauth.js:      formDataKeys: Array.from(setData.keys()),
./backend/monolith/src/api/routes/oauth.js:          'X-Authorization': client.session.token,
./backend/monolith/src/api/routes/oauth.js:          'X-Authorization': client.session.token,
./backend/monolith/src/api/routes/oauth.js:    params.set('access_type', 'offline')    // Request refresh token
./backend/monolith/src/api/routes/oauth.js:  const tokenResponse = await axios.post(
./backend/monolith/src/api/routes/oauth.js:    'https://oauth.yandex.ru/token',
./backend/monolith/src/api/routes/oauth.js:      client_secret: process.env.YANDEX_CLIENT_SECRET,
./backend/monolith/src/api/routes/oauth.js:  const accessToken = tokenResponse.data.access_token
./backend/monolith/src/api/routes/oauth.js:  const tokenResponse = await axios.post(
./backend/monolith/src/api/routes/oauth.js:    'https://oauth2.googleapis.com/token',
./backend/monolith/src/api/routes/oauth.js:      client_secret: process.env.GOOGLE_CLIENT_SECRET,
./backend/monolith/src/api/routes/oauth.js:  const accessToken = tokenResponse.data.access_token
./backend/monolith/src/api/routes/oauth.js:  // Build token request parameters
./backend/monolith/src/api/routes/oauth.js:  const tokenParams = new URLSearchParams({
./backend/monolith/src/api/routes/oauth.js:    tokenParams.set('code_verifier', codeVerifier)
./backend/monolith/src/api/routes/oauth.js:  }, 'VK ID: Requesting access token')
./backend/monolith/src/api/routes/oauth.js:  const tokenResponse = await axios.post(
./backend/monolith/src/api/routes/oauth.js:    tokenParams,
./backend/monolith/src/api/routes/oauth.js:  logger.info({ responseKeys: Object.keys(tokenResponse.data) }, 'VK ID: Token response received')
./backend/monolith/src/api/routes/oauth.js:  const { access_token, user_id, email } = tokenResponse.data
./backend/monolith/src/api/routes/oauth.js:      access_token: access_token,
./backend/monolith/src/api/routes/oauth.js:    for (const [key, value] of oauthStates.entries()) {
./backend/monolith/src/api/routes/oauth.js:      if (value.createdAt < tenMinutesAgo) oauthStates.delete(key)
./backend/monolith/src/api/routes/oauth.js:    // Generate JWT tokens for the OAuth user
./backend/monolith/src/api/routes/oauth.js:    // Create default AI token for new OAuth users
./backend/monolith/src/api/routes/oauth.js:        logger.warn({ userId, error: err.message }, 'Failed to create default token for OAuth user')
./backend/monolith/src/api/routes/oauth.js:    // Redirect to frontend with tokens (both JWT and Integram for legacy PHP)
./backend/monolith/src/api/routes/oauth.js:    if (integramToken) params.append('token', integramToken)
./backend/monolith/src/api/routes/oauth.js:    // Generate JWT tokens
./backend/monolith/src/api/routes/oauth.js:        logger.warn({ userId, error: err.message }, 'Failed to create default token for OAuth user')
./backend/monolith/src/api/routes/oauth.js:    // Redirect to frontend with tokens (both JWT and Integram for legacy PHP)
./backend/monolith/src/api/routes/oauth.js:    if (integramToken) params.append('token', integramToken)
./backend/monolith/src/api/routes/oauth.js:    logger.info({ hasCodeVerifier: !!codeVerifier }, 'VK OAuth: Exchanging code for token')
./backend/monolith/src/api/routes/oauth.js:    // Generate JWT tokens
./backend/monolith/src/api/routes/oauth.js:        logger.warn({ userId, error: err.message }, 'Failed to create default token for OAuth user')
./backend/monolith/src/api/routes/oauth.js:    // Redirect to frontend with tokens (both JWT and Integram for legacy PHP)
./backend/monolith/src/api/routes/oauth.js:    if (integramToken) params.append('token', integramToken)
./backend/monolith/src/api/routes/oauth.js:    const checkString = Object.keys(data)
./backend/monolith/src/api/routes/oauth.js:      .map(key => `${key}=${data[key]}`)
./backend/monolith/src/api/routes/oauth.js:    const secretKey = crypto.createHash('sha256')
./backend/monolith/src/api/routes/oauth.js:    const expectedHash = crypto.createHmac('sha256', secretKey)
./backend/monolith/src/api/routes/oauth.js:    // Generate JWT tokens
./backend/monolith/src/api/routes/oauth.js:    // Create default AI token for new OAuth users
./backend/monolith/src/api/routes/oauth.js:        logger.warn({ userId, error: err.message }, 'Failed to create default token for Telegram user')
./backend/monolith/src/api/routes/oauth.js:        token: integramToken,
./backend/monolith/src/api/routes/oauth.js:    const blacklistArray = Array.from(oauthBlacklist.entries()).map(([key, value]) => {
./backend/monolith/src/api/routes/oauth.js:      const [provider, userId] = key.split('_')
./backend/monolith/src/api/routes/oauth.js:    const key = `${provider}_${userId}`
./backend/monolith/src/api/routes/oauth.js:    if (!oauthBlacklist.has(key)) {
./backend/monolith/src/api/routes/oauth.js:    oauthBlacklist.delete(key)
./backend/monolith/src/api/routes/chat.js:        description: 'Authenticate with Integram API using login and password. MUST be called first before using any other Integram tools.',
./backend/monolith/src/api/routes/chat.js:            password: { type: 'string', description: 'Login password' }
./backend/monolith/src/api/routes/chat.js:          required: ['serverURL', 'database', 'login', 'password']
./backend/monolith/src/api/routes/chat.js:              description: 'Object requisites as key-value pairs (requisiteId: value)',
./backend/monolith/src/api/routes/chat.js:          `user_${userId}`, // Simple token format
./backend/monolith/src/utils/metrics.js:    Object.keys(this.metrics).forEach(key => {
./backend/monolith/src/utils/metrics.js:      this.metrics[key] = 0;
./backend/monolith/src/utils/egrulExtractor.js: * @returns {Object} Extracted fields with parameter IDs as keys
./backend/monolith/src/utils/auth/cookies.js: * Secure cookie handling for JWT tokens
./backend/monolith/src/utils/auth/cookies.js:  // Access token cookie (short-lived)
./backend/monolith/src/utils/auth/cookies.js:    name: 'access_token',
./backend/monolith/src/utils/auth/cookies.js:  // Refresh token cookie (long-lived)
./backend/monolith/src/utils/auth/cookies.js:    name: 'refresh_token',
./backend/monolith/src/utils/auth/cookies.js:  // XSRF token cookie (readable by JS for CSRF protection)
./backend/monolith/src/utils/auth/cookies.js:    name: 'xsrf_token',
./backend/monolith/src/utils/auth/cookies.js: * Set access token cookie
./backend/monolith/src/utils/auth/cookies.js: * @param {string} token - JWT access token
./backend/monolith/src/utils/auth/cookies.js:export function setAccessTokenCookie(res, token) {
./backend/monolith/src/utils/auth/cookies.js:    res.cookie(COOKIE_CONFIG.ACCESS_TOKEN.name, token, COOKIE_CONFIG.ACCESS_TOKEN)
./backend/monolith/src/utils/auth/cookies.js:    logger.debug('Access token cookie set')
./backend/monolith/src/utils/auth/cookies.js:    logger.error({ error: error.message }, 'Failed to set access token cookie')
./backend/monolith/src/utils/auth/cookies.js: * Set refresh token cookie
./backend/monolith/src/utils/auth/cookies.js: * @param {string} token - JWT refresh token
./backend/monolith/src/utils/auth/cookies.js:export function setRefreshTokenCookie(res, token) {
./backend/monolith/src/utils/auth/cookies.js:    res.cookie(COOKIE_CONFIG.REFRESH_TOKEN.name, token, COOKIE_CONFIG.REFRESH_TOKEN)
./backend/monolith/src/utils/auth/cookies.js:    logger.debug('Refresh token cookie set')
./backend/monolith/src/utils/auth/cookies.js:    logger.error({ error: error.message }, 'Failed to set refresh token cookie')
./backend/monolith/src/utils/auth/cookies.js: * Set XSRF token cookie
./backend/monolith/src/utils/auth/cookies.js: * @param {string} token - XSRF token
./backend/monolith/src/utils/auth/cookies.js:export function setXSRFTokenCookie(res, token) {
./backend/monolith/src/utils/auth/cookies.js:    res.cookie(COOKIE_CONFIG.XSRF_TOKEN.name, token, COOKIE_CONFIG.XSRF_TOKEN)
./backend/monolith/src/utils/auth/cookies.js:    logger.debug('XSRF token cookie set')
./backend/monolith/src/utils/auth/cookies.js:    logger.error({ error: error.message }, 'Failed to set XSRF token cookie')
./backend/monolith/src/utils/auth/cookies.js: * @param {Object} tokens - { accessToken, refreshToken, xsrfToken }
./backend/monolith/src/utils/auth/cookies.js:export function setAuthCookies(res, tokens) {
./backend/monolith/src/utils/auth/cookies.js:  setAccessTokenCookie(res, tokens.accessToken)
./backend/monolith/src/utils/auth/cookies.js:  setRefreshTokenCookie(res, tokens.refreshToken)
./backend/monolith/src/utils/auth/cookies.js:  if (tokens.xsrfToken) {
./backend/monolith/src/utils/auth/cookies.js:    setXSRFTokenCookie(res, tokens.xsrfToken)
./backend/monolith/src/utils/auth/cookies.js: * Get access token from cookie
./backend/monolith/src/utils/auth/cookies.js: * @returns {string|null} Access token or null
./backend/monolith/src/utils/auth/cookies.js: * Get refresh token from cookie
./backend/monolith/src/utils/auth/cookies.js: * @returns {string|null} Refresh token or null
./backend/monolith/src/utils/auth/cookies.js: * Get XSRF token from cookie
./backend/monolith/src/utils/auth/cookies.js: * @returns {string|null} XSRF token or null
./backend/monolith/src/utils/auth/cookies.js: * Generate XSRF token
./backend/monolith/src/utils/auth/cookies.js: * @returns {string} Random XSRF token
./backend/monolith/src/utils/auth/cookies.js: * Validate XSRF token
./backend/monolith/src/utils/auth/password.js: * Hash password using bcrypt
./backend/monolith/src/utils/auth/password.js: * @param {string} password - Plain text password
./backend/monolith/src/utils/auth/password.js: * @returns {Promise<string>} Hashed password
./backend/monolith/src/utils/auth/password.js:export async function hashPassword(password) {
./backend/monolith/src/utils/auth/password.js:  return await bcrypt.hash(password, BCRYPT_ROUNDS)
./backend/monolith/src/utils/auth/password.js: * Compare password with hash
./backend/monolith/src/utils/auth/password.js: * @param {string} password - Plain text password
./backend/monolith/src/utils/auth/password.js: * @returns {Promise<boolean>} True if password matches
./backend/monolith/src/utils/auth/password.js:export async function comparePassword(password, hash) {
./backend/monolith/src/utils/auth/password.js:  return await bcrypt.compare(password, hash)
./backend/monolith/src/utils/auth/password.js: * Validate password strength
./backend/monolith/src/utils/auth/password.js: * @param {string} password - Password to validate
./backend/monolith/src/utils/auth/password.js:export function validatePasswordStrength(password) {
./backend/monolith/src/utils/auth/password.js:  if (!password || password.length < 8) {
./backend/monolith/src/utils/auth/password.js:  if (!/[a-z]/.test(password)) {
./backend/monolith/src/utils/auth/password.js:  if (!/[A-Z]/.test(password)) {
./backend/monolith/src/utils/auth/password.js:  if (!/[0-9]/.test(password)) {
./backend/monolith/src/utils/auth/password.js:  if (!/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password)) {
./backend/monolith/src/utils/auth/password.js: * Generate random password
./backend/monolith/src/utils/auth/password.js: * @returns {string} Random password
./backend/monolith/src/utils/auth/password.js:  let password = ''
./backend/monolith/src/utils/auth/password.js:  password += lowercase[Math.floor(Math.random() * lowercase.length)]
./backend/monolith/src/utils/auth/password.js:  password += uppercase[Math.floor(Math.random() * uppercase.length)]
./backend/monolith/src/utils/auth/password.js:  password += numbers[Math.floor(Math.random() * numbers.length)]
./backend/monolith/src/utils/auth/password.js:  password += symbols[Math.floor(Math.random() * symbols.length)]
./backend/monolith/src/utils/auth/password.js:  for (let i = password.length; i < length; i++) {
./backend/monolith/src/utils/auth/password.js:    password += all[Math.floor(Math.random() * all.length)]
./backend/monolith/src/utils/auth/password.js:  // Shuffle the password
./backend/monolith/src/utils/auth/password.js:  return password.split('').sort(() => Math.random() - 0.5).join('')
./backend/monolith/src/utils/auth/jwt.js:import jwt from 'jsonwebtoken'
./backend/monolith/src/utils/auth/jwt.js:const DEFAULT_DEV_SECRET = 'dev-secret-change-before-production-954c4f428e58ebc3e05752df7918dbef271657bdc7de62794e3ef7bd24010244'
./backend/monolith/src/utils/auth/jwt.js:    console.warn('‚ö†Ô∏è  JWT_SECRET not set! Using default dev secret.')
./backend/monolith/src/utils/auth/jwt.js:    console.warn('   Generate proper secret: node scripts/generate-jwt-secret.js')
./backend/monolith/src/utils/auth/jwt.js:      'Generate a strong secret with: node scripts/generate-jwt-secret.js\n' +
./backend/monolith/src/utils/auth/jwt.js:      'Then add it to your .env file: JWT_SECRET=<generated_secret>\n' +
./backend/monolith/src/utils/auth/jwt.js:    'Generate a stronger secret with: node scripts/generate-jwt-secret.js'
./backend/monolith/src/utils/auth/jwt.js:// Warn if using common weak secrets
./backend/monolith/src/utils/auth/jwt.js:  'secret',
./backend/monolith/src/utils/auth/jwt.js:  'default-secret-change-in-production',
./backend/monolith/src/utils/auth/jwt.js:  'your-jwt-secret',
./backend/monolith/src/utils/auth/jwt.js:  'password',
./backend/monolith/src/utils/auth/jwt.js:    'This makes your application vulnerable to token forgery. ' +
./backend/monolith/src/utils/auth/jwt.js:    'Generate a strong secret immediately with: node scripts/generate-jwt-secret.js'
./backend/monolith/src/utils/auth/jwt.js: * Generate JWT access token
./backend/monolith/src/utils/auth/jwt.js: * @returns {string} JWT access token
./backend/monolith/src/utils/auth/jwt.js: * Generate JWT refresh token
./backend/monolith/src/utils/auth/jwt.js: * @returns {string} JWT refresh token
./backend/monolith/src/utils/auth/jwt.js: * Generate both access and refresh tokens
./backend/monolith/src/utils/auth/jwt.js: * Verify and decode JWT token
./backend/monolith/src/utils/auth/jwt.js: * @param {string} token - JWT token to verify
./backend/monolith/src/utils/auth/jwt.js: * @returns {Object} Decoded token payload
./backend/monolith/src/utils/auth/jwt.js: * @throws {Error} If token is invalid or expired
./backend/monolith/src/utils/auth/jwt.js:export function verifyToken(token) {
./backend/monolith/src/utils/auth/jwt.js:    return jwt.verify(token, JWT_SECRET, {
./backend/monolith/src/utils/auth/jwt.js:      throw new Error('Invalid token')
./backend/monolith/src/utils/auth/jwt.js: * Hash token for storage (SHA-256)
./backend/monolith/src/utils/auth/jwt.js: * @param {string} token - Token to hash
./backend/monolith/src/utils/auth/jwt.js: * @returns {string} Hashed token
./backend/monolith/src/utils/auth/jwt.js:export function hashToken(token) {
./backend/monolith/src/utils/auth/jwt.js:  return crypto.createHash('sha256').update(token).digest('hex')
./backend/monolith/src/utils/auth/jwt.js: * Generate random token string
./backend/monolith/src/utils/auth/jwt.js: * @returns {string} Random hex token
./backend/monolith/src/utils/auth/jwt.js: * Calculate token expiration time
./backend/monolith/src/utils/memoryOptimization.js:  set(key, value) {
./backend/monolith/src/utils/memoryOptimization.js:    if (this.map.size >= this.maxSize && !this.map.has(key)) {
./backend/monolith/src/utils/memoryOptimization.js:      // Remove oldest entry (but skip protected keys)
./backend/monolith/src/utils/memoryOptimization.js:      console.error(`[BoundedMap] Map full (${this.map.size}/${this.maxSize}), need to evict. Protected keys:`, Array.from(this.protectedKeys));
./backend/monolith/src/utils/memoryOptimization.js:      for (const k of this.map.keys()) {
./backend/monolith/src/utils/memoryOptimization.js:          console.error(`[BoundedMap] Evicting key: ${k}`);
./backend/monolith/src/utils/memoryOptimization.js:          console.error(`[BoundedMap] Skipping protected key: ${k}`);
./backend/monolith/src/utils/memoryOptimization.js:        console.error(`[BoundedMap] WARNING: No evictable keys found! All keys are protected.`);
./backend/monolith/src/utils/memoryOptimization.js:    this.map.set(key, value);
./backend/monolith/src/utils/memoryOptimization.js:  get(key) {
./backend/monolith/src/utils/memoryOptimization.js:    return this.map.get(key);
./backend/monolith/src/utils/memoryOptimization.js:  has(key) {
./backend/monolith/src/utils/memoryOptimization.js:    return this.map.has(key);
./backend/monolith/src/utils/memoryOptimization.js:  delete(key) {
./backend/monolith/src/utils/memoryOptimization.js:    return this.map.delete(key);
./backend/monolith/src/utils/memoryOptimization.js:  keys() {
./backend/monolith/src/utils/memoryOptimization.js:    return this.map.keys();
./backend/monolith/src/utils/memoryOptimization.js:  set(key, value) {
./backend/monolith/src/utils/memoryOptimization.js:    if (this.cache.size >= this.maxSize && !this.cache.has(key)) {
./backend/monolith/src/utils/memoryOptimization.js:      // Remove least recently used (first key)
./backend/monolith/src/utils/memoryOptimization.js:      const firstKey = this.cache.keys().next().value;
./backend/monolith/src/utils/memoryOptimization.js:    if (this.cache.has(key)) {
./backend/monolith/src/utils/memoryOptimization.js:      this.cache.delete(key);
./backend/monolith/src/utils/memoryOptimization.js:    this.cache.set(key, value);
./backend/monolith/src/utils/memoryOptimization.js:  get(key) {
./backend/monolith/src/utils/memoryOptimization.js:    if (!this.cache.has(key)) return undefined;
./backend/monolith/src/utils/memoryOptimization.js:    const value = this.cache.get(key);
./backend/monolith/src/utils/memoryOptimization.js:    this.cache.delete(key);
./backend/monolith/src/utils/memoryOptimization.js:    this.cache.set(key, value);
./backend/monolith/src/utils/memoryOptimization.js:  has(key) {
./backend/monolith/src/utils/memoryOptimization.js:    return this.cache.has(key);
./backend/monolith/src/utils/memoryOptimization.js:  delete(key) {
./backend/monolith/src/utils/memoryOptimization.js:    return this.cache.delete(key);
./backend/monolith/src/utils/memoryOptimization.js:  keys() {
./backend/monolith/src/utils/memoryOptimization.js:    return this.cache.keys();
./backend/monolith/src/utils/memoryOptimization.js:  set(key, value) {
./backend/monolith/src/utils/memoryOptimization.js:    this.cache.set(key, { value, expiry });
./backend/monolith/src/utils/memoryOptimization.js:  get(key) {
./backend/monolith/src/utils/memoryOptimization.js:    const entry = this.cache.get(key);
./backend/monolith/src/utils/memoryOptimization.js:      this.cache.delete(key);
./backend/monolith/src/utils/memoryOptimization.js:  has(key) {
./backend/monolith/src/utils/memoryOptimization.js:    const entry = this.cache.get(key);
./backend/monolith/src/utils/memoryOptimization.js:      this.cache.delete(key);
./backend/monolith/src/utils/memoryOptimization.js:  delete(key) {
./backend/monolith/src/utils/memoryOptimization.js:    return this.cache.delete(key);
./backend/monolith/src/utils/memoryOptimization.js:    for (const [key, entry] of this.cache.entries()) {
./backend/monolith/src/utils/memoryOptimization.js:        this.cache.delete(key);
./backend/monolith/src/utils/githubWebhook.js: * GitHub signs webhook payloads with HMAC-SHA256 using the webhook secret.
./backend/monolith/src/utils/githubWebhook.js: * @param {string} secret - Webhook secret from GitHub
./backend/monolith/src/utils/githubWebhook.js:export function verifyGitHubSignature(req, secret) {
./backend/monolith/src/utils/githubWebhook.js:  if (!secret) {
./backend/monolith/src/utils/githubWebhook.js:    logger.warn('GitHub webhook secret not configured - skipping signature verification');
./backend/monolith/src/utils/githubWebhook.js:    return true; // Allow in development without secret
./backend/monolith/src/utils/githubWebhook.js:  const hmac = crypto.createHmac('sha256', secret);
./backend/monolith/src/utils/IntegramClient.js:   * @param {string} password - Password
./backend/monolith/src/utils/IntegramClient.js:   * @returns {Promise<Object>} Authentication result with tokens
./backend/monolith/src/utils/IntegramClient.js:  async authenticate(username, password) {
./backend/monolith/src/utils/IntegramClient.js:      formData.append('pwd', password);
./backend/monolith/src/utils/IntegramClient.js:        throw new Error('Invalid login or password');
./backend/monolith/src/utils/IntegramClient.js:      // The auth response already contains token, _xsrf, id, etc.
./backend/monolith/src/utils/IntegramClient.js:        token: response.data.token,
./backend/monolith/src/utils/IntegramClient.js:          'X-Authorization': this.session.token
./backend/monolith/src/utils/IntegramClient.js:      // _m_save correctly saves password, _m_set does not
./backend/monolith/src/utils/IntegramClient.js:      if (userData.password) {
./backend/monolith/src/utils/IntegramClient.js:        saveData.append('t20', userData.password);
./backend/monolith/src/utils/IntegramClient.js:          t20: userData.password ? '[PLAIN_PASSWORD]' : (userData.password_hash ? '[HASH]' : '[NONE]'),
./backend/monolith/src/utils/IntegramClient.js:          hasPassword: !!userData.password,
./backend/monolith/src/utils/IntegramClient.js:          hasPasswordHash: !!userData.password_hash
./backend/monolith/src/utils/IntegramClient.js:          'X-Authorization': this.session.token
./backend/monolith/src/utils/IntegramClient.js:          'X-Authorization': this.session.token
./backend/monolith/src/utils/IntegramClient.js:    // Also include xsrf token if available
./backend/monolith/src/models/WitnessValidation.js:    valid: Object.keys(errors).length === 0,
./backend/monolith/src/middleware/security/securityHeaders.js:    'X-Authorization',      // AI tokens API (Issue #1823)
./backend/monolith/src/middleware/security/securityHeaders.js:    'X-Integram-XSRF',      // Integram XSRF token (torgi-parser)
./backend/monolith/src/middleware/security/requestValidation.js:  const queryParams = Object.keys(req.query);
./backend/monolith/src/middleware/security/requestValidation.js:  for (const [key, value] of Object.entries(req.query)) {
./backend/monolith/src/middleware/security/requestValidation.js:    //   logger.error(`SQL injection attempt in query: ${key}=${stringValue} from ${req.ip}`);
./backend/monolith/src/middleware/security/requestValidation.js:      logger.error(`XSS attempt in query: ${key}=${stringValue} from ${req.ip}`);
./backend/monolith/src/middleware/security/requestValidation.js:      logger.error(`Path traversal attempt in query: ${key}=${stringValue} from ${req.ip}`);
./backend/monolith/src/middleware/security/requestValidation.js:    '/api/ai-tokens/chat',
./backend/monolith/src/middleware/security/requestValidation.js:    '/api/ai-tokens/completions',
./backend/monolith/src/middleware/security/requestValidation.js:  // Use originalUrl to get full path including prefix (e.g., /api/ai-tokens/chat)
./backend/monolith/src/middleware/security/requestValidation.js:    for (const [key, value] of Object.entries(obj)) {
./backend/monolith/src/middleware/security/requestValidation.js:      const currentPath = path ? `${path}.${key}` : key;
./backend/monolith/src/middleware/security/requestValidation.js:    for (const [key, value] of Object.entries(obj)) {
./backend/monolith/src/middleware/security/requestValidation.js:        sanitized[key] = sanitizeInput(value);
./backend/monolith/src/middleware/security/requestValidation.js:        sanitized[key] = Array.isArray(value) ? value.map((v) => (typeof v === 'object' ? sanitizeObject(v) : v)) : sanitizeObject(value);
./backend/monolith/src/middleware/security/requestValidation.js:        sanitized[key] = value;
./backend/monolith/src/middleware/security/rateLimiter.js:  // Try to get user ID from JWT token
./backend/monolith/src/middleware/security/rateLimiter.js:  keyGenerator: (req) => req.ip,
./backend/monolith/src/middleware/security/rateLimiter.js:    keyGenerator: getUserKey,
./backend/monolith/src/middleware/security/rateLimiter.js:  keyGenerator: (req) => req.ip,
./backend/monolith/src/middleware/security/rateLimiter.js:  keyGenerator: (req) => req.ip,
./backend/monolith/src/middleware/security/rateLimiter.js: * Rate limiter for password reset endpoints
./backend/monolith/src/middleware/security/rateLimiter.js: * Prevents password reset abuse
./backend/monolith/src/middleware/security/rateLimiter.js:export const passwordResetLimiter = createRateLimiter({
./backend/monolith/src/middleware/security/rateLimiter.js:  prefix: 'rl:password:',
./backend/monolith/src/middleware/security/rateLimiter.js:  keyGenerator: (req) => req.ip,
./backend/monolith/src/middleware/security/rateLimiter.js:  keyGenerator: (req) => req.ip,
./backend/monolith/src/middleware/security/rateLimiter.js:  keyGenerator: getUserKey,
./backend/monolith/src/middleware/security/rateLimiter.js:  keyGenerator: getUserKey,
./backend/monolith/src/middleware/security/rateLimiter.js:  keyGenerator: getUserKey,
./backend/monolith/src/middleware/security/rateLimiter.js:    keyGenerator: getUserKey,
./backend/monolith/src/middleware/security/rateLimiter.js:  passwordResetLimiter,
./backend/monolith/src/middleware/security/abuseDetection.js:  const key = `abuse:failed_login:${ip}:${username}`;
./backend/monolith/src/middleware/security/abuseDetection.js:  const currentCount = memoryStore.failedLogins.get(key) || 0;
./backend/monolith/src/middleware/security/abuseDetection.js:  memoryStore.failedLogins.set(key, newCount);
./backend/monolith/src/middleware/security/abuseDetection.js:  setTimeout(() => memoryStore.failedLogins.delete(key), ABUSE_CONFIG.failedLoginWindow);
./backend/monolith/src/middleware/security/abuseDetection.js:  const key = `abuse:failed_login:${ip}:${username}`;
./backend/monolith/src/middleware/security/abuseDetection.js:  memoryStore.failedLogins.delete(key);
./backend/monolith/src/middleware/security/abuseDetection.js:  const key = `abuse:suspicious:${ip}`;
./backend/monolith/src/middleware/security/abuseDetection.js:    const key = `abuse:credential_stuffing:${ip}`;
./backend/monolith/src/middleware/security/abuseDetection.js:    const attempts = (memoryStore.suspiciousIPs.get(key) || 0) + 1;
./backend/monolith/src/middleware/security/abuseDetection.js:    memoryStore.suspiciousIPs.set(key, attempts);
./backend/monolith/src/middleware/security/abuseDetection.js:    setTimeout(() => memoryStore.suspiciousIPs.delete(key), 300000); // 5 minutes
./backend/monolith/src/middleware/auth/rateLimiter.js: * Rate limiter for password reset endpoints
./backend/monolith/src/middleware/auth/rateLimiter.js:export const passwordResetLimiter = rateLimit({
./backend/monolith/src/middleware/auth/rateLimiter.js:  max: 3, // Limit each IP to 3 password reset requests per hour
./backend/monolith/src/middleware/auth/rateLimiter.js:  passwordResetLimiter,
./backend/monolith/src/middleware/auth/auth.js: * Authentication middleware - verifies JWT token
./backend/monolith/src/middleware/auth/auth.js: * 2. Authorization header: Bearer <token> (backward compatibility)
./backend/monolith/src/middleware/auth/auth.js:    let token = null
./backend/monolith/src/middleware/auth/auth.js:    token = getAccessTokenFromCookie(req)
./backend/monolith/src/middleware/auth/auth.js:    if (!token) {
./backend/monolith/src/middleware/auth/auth.js:        token = authHeader.substring(7) // Remove 'Bearer ' prefix
./backend/monolith/src/middleware/auth/auth.js:    // No token found in either location
./backend/monolith/src/middleware/auth/auth.js:    if (!token) {
./backend/monolith/src/middleware/auth/auth.js:        error: 'No authentication token provided',
./backend/monolith/src/middleware/auth/auth.js:    // Verify token
./backend/monolith/src/middleware/auth/auth.js:    const decoded = verifyToken(token)
./backend/monolith/src/middleware/auth/auth.js:      error: error.message || 'Invalid authentication token',
./backend/monolith/src/middleware/auth/auth.js: * Optional authentication middleware - doesn't fail if no token
./backend/monolith/src/middleware/auth/auth.js:      const token = authHeader.substring(7)
./backend/monolith/src/middleware/auth/auth.js:      const decoded = verifyToken(token)
./backend/monolith/src/middleware/auth/myTokenAuth.js: * 1. When logging into 'my' database, users obtain an authorization token
./backend/monolith/src/middleware/auth/myTokenAuth.js: * 2. The token is passed using the 'my: {token}' header for cross-database access
./backend/monolith/src/middleware/auth/myTokenAuth.js: * 4. If logging into a specific database (not 'my'), use that database's specific token
./backend/monolith/src/middleware/auth/myTokenAuth.js: * - For 'my' database token: my: {token_value}
./backend/monolith/src/middleware/auth/myTokenAuth.js: * - For specific database: X-Authorization: {token_value}
./backend/monolith/src/middleware/auth/myTokenAuth.js: * This enables a unified authentication model where a single 'my' token
./backend/monolith/src/middleware/auth/myTokenAuth.js: * Middleware to handle 'my:' token authorization
./backend/monolith/src/middleware/auth/myTokenAuth.js: * 2. If present, extracts the token and sets it for downstream use
./backend/monolith/src/middleware/auth/myTokenAuth.js:    // Extract 'my:' token from header
./backend/monolith/src/middleware/auth/myTokenAuth.js:      // Store 'my' token in request for downstream middleware
./backend/monolith/src/middleware/auth/myTokenAuth.js:      // This allows existing middleware to work with the 'my' token
./backend/monolith/src/middleware/auth/myTokenAuth.js: * Middleware to validate 'my' token and check database access
./backend/monolith/src/middleware/auth/myTokenAuth.js: * It validates that the 'my' token grants access to the requested database.
./backend/monolith/src/middleware/auth/myTokenAuth.js:        error: 'Authentication required. Please provide my: header with valid token.'
./backend/monolith/src/middleware/auth/myTokenAuth.js:    // This just ensures the token is present
./backend/monolith/src/middleware/auth/myTokenAuth.js:    }, 'my: token validated');
./backend/monolith/src/middleware/auth/myTokenAuth.js:      error: 'Internal server error during token validation'
./backend/monolith/src/middleware/auth/myTokenAuth.js: * Utility function to get the appropriate authorization token for a database
./backend/monolith/src/middleware/auth/myTokenAuth.js: * This function determines which token to use based on:
./backend/monolith/src/middleware/auth/myTokenAuth.js: * 1. If 'my:' header is present and database is accessible via 'my', use my token
./backend/monolith/src/middleware/auth/myTokenAuth.js: * 2. Otherwise, use database-specific token from session
./backend/monolith/src/middleware/auth/myTokenAuth.js: * @returns {string|null} Authorization token or null
./backend/monolith/src/middleware/auth/myTokenAuth.js:      authMethod: 'my-token'
./backend/monolith/src/middleware/auth/myTokenAuth.js:    }, 'Using my: token for database access');
./backend/monolith/src/middleware/auth/myTokenAuth.js:  // Otherwise, use database-specific token from session
./backend/monolith/src/middleware/auth/myTokenAuth.js:      }, 'Using database-specific token');
./backend/monolith/src/middleware/auth/myTokenAuth.js:      return dbAuth.token;
./backend/monolith/src/middleware/auth/myTokenAuth.js:  }, 'No authorization token found for database');
./backend/monolith/src/middleware/auth/myTokenAuth.js: * Middleware to inject 'my:' token into Integram API requests
./backend/monolith/src/middleware/auth/myTokenAuth.js:    // If request has 'my' token and is targeting Integram API
./backend/monolith/src/index.js:import aiTokenRoutes from './api/routes/ai-tokens.js';
./backend/monolith/src/index.js:import tokenManagementRoutes from './api/routes/token-management.js';
./backend/monolith/src/index.js:import secretsRoutes from './api/routes/secrets.js';
./backend/monolith/src/index.js:import organizationSecretsRoutes from './api/routes/organization-secrets.js';
./backend/monolith/src/index.js:  passwordResetLimiter,
./backend/monolith/src/index.js:      sslKeyPath: config.sslKeyPath || process.env.SSL_KEY_PATH || '/etc/letsencrypt/live/drondoc.ru/privkey.pem',
./backend/monolith/src/index.js:    this.app.use('/api/ai-tokens', aiTokenRoutes);
./backend/monolith/src/index.js:    // Store and retrieve Git tokens in Integram /my database
./backend/monolith/src/index.js:    // Email-based user registration, verification, password reset
./backend/monolith/src/index.js:    this.app.use('/api/tokens', tokenManagementRoutes);
./backend/monolith/src/index.js:    console.log('‚úÖ [MONOLITH] Token management routes registered at /api/tokens (Issue #2784)');
./backend/monolith/src/index.js:    this.app.use('/api/secrets', secretsRoutes);
./backend/monolith/src/index.js:    console.log('‚úÖ [MONOLITH] Secrets Management routes registered at /api/secrets (Issue #2471)');
./backend/monolith/src/index.js:          ai: 'AI tokens and agent services',
./backend/monolith/src/index.js:          aiTokens: '/api/ai-tokens',
./backend/monolith/src/index.js:            keyPath: this.config.sslKeyPath
./backend/monolith/src/index.js:            key: fs.readFileSync(this.config.sslKeyPath)
./backend/monolith/src/index.js:          console.log(`   Private key size: ${httpsOptions.key.length} bytes`);
./backend/monolith/src/index.js:            keyPath: this.config.sslKeyPath
./backend/monolith/src/index.js:            keyPath: this.config.sslKeyPath
./backend/monolith/src/index.js:          console.error(`   Private key path: ${this.config.sslKeyPath}`);
./backend/monolith/src/index.js:      // Log GitHub token configuration status (Issue #2266)
./backend/monolith/src/index.js:        logger.info(`GitHub token preview: ${process.env.GITHUB_TOKEN.substring(0, 10)}***`);
./backend/monolith/src/index.js:        logger.info(`GH_TOKEN token preview: ${process.env.GH_TOKEN.substring(0, 10)}***`);
./backend/monolith/src/index.js:        logger.warn('‚ö†Ô∏è  No GitHub token found in environment variables!');
./backend/monolith/src/index.js:        logger.warn('üí° Set GITHUB_TOKEN environment variable or add GitHub API key via /api/ai-tokens/provider-keys');
./backend/monolith/src/core/CodeReviewCoordinator.js:      this.logger.warn('GitHub token not found - code review will be limited')
./backend/monolith/src/core/CodeReviewCoordinator.js:   * Get GitHub token from database or environment
./backend/monolith/src/core/CodeReviewCoordinator.js:    // Try to get from code_review_provider_keys table
./backend/monolith/src/core/CodeReviewCoordinator.js:        SELECT api_key_encrypted
./backend/monolith/src/core/CodeReviewCoordinator.js:        FROM code_review_provider_keys
./backend/monolith/src/core/CodeReviewCoordinator.js:        const encryptedKey = result.rows[0].api_key_encrypted
./backend/monolith/src/core/CodeReviewCoordinator.js:      this.logger.error('Failed to retrieve GitHub token', {
./backend/monolith/src/core/CodeReviewCoordinator.js:   * Get or create default system token for code reviews
./backend/monolith/src/core/CodeReviewCoordinator.js:      // Try to find existing system token for code reviews
./backend/monolith/src/core/CodeReviewCoordinator.js:        SELECT id, token_hash, token_prefix
./backend/monolith/src/core/CodeReviewCoordinator.js:        FROM ai_access_tokens
./backend/monolith/src/core/CodeReviewCoordinator.js:      // Create new system token
./backend/monolith/src/core/CodeReviewCoordinator.js:      const tokenValue = 'dd_sys_' + crypto.randomBytes(32).toString('base64url')
./backend/monolith/src/core/CodeReviewCoordinator.js:      const tokenHash = crypto.createHash('sha256').update(tokenValue).digest('hex')
./backend/monolith/src/core/CodeReviewCoordinator.js:      const tokenPrefix = tokenValue.substring(0, 20)
./backend/monolith/src/core/CodeReviewCoordinator.js:        INSERT INTO ai_access_tokens (
./backend/monolith/src/core/CodeReviewCoordinator.js:          token_hash,
./backend/monolith/src/core/CodeReviewCoordinator.js:          token_prefix,
./backend/monolith/src/core/CodeReviewCoordinator.js:          token_balance,
./backend/monolith/src/core/CodeReviewCoordinator.js:      `, [tokenHash, tokenPrefix])
./backend/monolith/src/core/CodeReviewCoordinator.js:      this.logger.info('Created new system token for code reviews')
./backend/monolith/src/core/CodeReviewCoordinator.js:      this.logger.error('Failed to get/create default review token', {
./backend/monolith/src/core/CodeReviewCoordinator.js:      // Get system token
./backend/monolith/src/core/CodeReviewCoordinator.js:          ai_token_id
./backend/monolith/src/core/CodeReviewCoordinator.js:          totalTokens += fileResult.tokensUsed || 0
./backend/monolith/src/core/CodeReviewCoordinator.js:          tokens_used = $3,
./backend/monolith/src/core/CodeReviewCoordinator.js:        tokensUsed: totalTokens,
./backend/monolith/src/core/CodeReviewCoordinator.js:    let tokensUsed = 0
./backend/monolith/src/core/CodeReviewCoordinator.js:        tokensUsed += aiResult.tokensUsed || 0
./backend/monolith/src/core/CodeReviewCoordinator.js:      tokensUsed,
./backend/monolith/src/core/AgentRegistry.js:    for (const agentId of this.heartbeatTimers.keys()) {
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:// TokenBasedLLMCoordinator.js - Extended LLM management with token-based auth
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:// Extends LLMCoordinator to support dynamic model selection via access tokens
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:import tokenConsumptionLogger from '../services/ai/tokenConsumptionLogger.js'
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:    this.tokenCache = new LRUCache(5000) // Cache up to 5,000 validated tokens
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:   - password: "d"
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:   * Validate access token and get permissions
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:   * @param {string} accessToken - The user's access token
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      throw new Error('Database not configured. AI token features require database connection.')
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:    const cached = this.tokenCache.get(cacheKey)
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:    // Hash the token
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        token_balance,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      FROM ai_access_tokens
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      WHERE token_hash = $1
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      throw new Error('Invalid access token')
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:    const tokenData = result.rows[0]
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:    // Validate token status
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:    if (!tokenData.is_active) {
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:    if (tokenData.expires_at && new Date(tokenData.expires_at) < new Date()) {
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:    if (tokenData.token_balance <= 0) {
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      throw new Error('Insufficient token balance')
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        COALESCE(SUM(CASE WHEN created_at >= CURRENT_DATE THEN total_tokens ELSE 0 END), 0) as daily_usage,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        COALESCE(SUM(CASE WHEN created_at >= DATE_TRUNC('month', CURRENT_DATE) THEN total_tokens ELSE 0 END), 0) as monthly_usage
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      FROM ai_token_usage
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      WHERE access_token_id = $1
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:    `, [tokenData.id])
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:    if (tokenData.daily_limit && usage.daily_usage >= tokenData.daily_limit) {
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      throw new Error('Daily token limit exceeded')
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:    if (tokenData.monthly_limit && usage.monthly_usage >= tokenData.monthly_limit) {
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      throw new Error('Monthly token limit exceeded')
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      tokenId: tokenData.id,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      userId: tokenData.user_id,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      name: tokenData.name,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      scopes: tokenData.scopes,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      allowedModels: tokenData.allowed_models,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      allowedApplications: tokenData.allowed_applications,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      rateLimitRpm: tokenData.rate_limit_rpm,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      rateLimitTpm: tokenData.rate_limit_tpm,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      tokenBalance: tokenData.token_balance,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      dailyLimit: tokenData.daily_limit,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      monthlyLimit: tokenData.monthly_limit
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:    this.tokenCache.set(cacheKey, {
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      UPDATE ai_access_tokens
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:    `, [tokenData.id])
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:   * Get default token for user
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:   * Issue #4722 - Fallback to DeepSeek if Polza API key is not configured
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:   * a virtual default token without database queries.
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:   * @returns {Promise<Object>} Result with token and default model
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:    // If database is not configured, return a virtual default token
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      // Create a virtual default token (no database storage needed)
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        token_prefix: 'dd_api_...',
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        token_balance: 999999999, // Effectively unlimited via DronDoc API
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      // Check which provider has an API key available (same logic as getModelConfig)
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      // Determine default model based on available API keys
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:          max_output_tokens: '8192',
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:          max_output_tokens: '8192',
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:          max_output_tokens: '8192',
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:          max_output_tokens: '8192',
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:          'No AI provider API keys configured. Please set at least one of: ' +
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:          token: defaultToken,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:    // If database is available (not currently the case), query for actual default token
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        SELECT * FROM ai_access_tokens
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        const token = result.rows[0]
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:            token,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      // No default token found, return error
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        error: 'No default token found for user'
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      // Check which provider has an API key available
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      const hasKodacodeKey = !!process.env.GITHUB_TOKEN; // Kodacode accepts GitHub token
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:          'No AI provider API keys configured. Please set at least one of: ' +
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        max_output_tokens: '8192',
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:   * @param {string} apiKey - API key for the provider
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:   * @param {string} apiKey - API key for the provider
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:   * Chat completion with token-based authentication
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:   * @param {string} accessToken - User's access token
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      apiKey = null, // User can provide their own API key
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:    // Validate token (skip if database is not configured)
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:    let tokenValidation = null
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      tokenValidation = await this.validateToken(accessToken)
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      if (!tokenValidation.allowedApplications.includes('*') &&
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:          !tokenValidation.allowedApplications.includes(application)) {
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        throw new Error(`Application '${application}' is not allowed for this token`)
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      if (!tokenValidation.allowedModels.includes('*') &&
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:          !tokenValidation.allowedModels.includes(modelId)) {
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        throw new Error(`Model is not allowed for this token`)
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      // When database is not configured, create a virtual token validation
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      tokenValidation = {
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        tokenId: accessToken, // Use accessToken as tokenId
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        tokenBalance: 999999999,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:    // Determine API key (user-provided or from environment)
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        `No API key configured for provider: ${modelConfig.provider_name}. ` +
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        `Please set ${envVarName} in backend .env file or provide your own API key. ` +
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:          prompt_tokens: response.usage?.promptTokens || 0,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:          completion_tokens: response.usage?.completionTokens || 0,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:          total_tokens: response.usage?.totalTokens || 0
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        tokenId: tokenValidation.tokenId,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        promptTokens: result.usage.prompt_tokens,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        completionTokens: result.usage.completion_tokens,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        tokenId: tokenValidation.tokenId,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:   * Get API key for a provider from environment
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      // Default: DeepSeek pricing ($0.14 input, $0.28 output per 1K tokens)
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      tokenId,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        INSERT INTO ai_token_usage (
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:          access_token_id,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:          prompt_tokens,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:          completion_tokens,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:          total_tokens,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        tokenId,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      // Deduct tokens from balance if successful
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:          UPDATE ai_access_tokens
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:          SET token_balance = GREATEST(token_balance - $1, 0)
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        `, [totalTokens, tokenId])
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        // Invalidate token cache
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        this.tokenCache.clear()
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        // Get userId from tokenId
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        const tokenResult = await this.db.query(`
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:          SELECT user_id FROM ai_access_tokens WHERE id = $1
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        `, [tokenId])
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        if (tokenResult.rows.length > 0) {
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:          const userId = tokenResult.rows[0].user_id
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:          tokenConsumptionLogger.logConsumption({
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:   * Get token cache key
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:  _getTokenCacheKey(token) {
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:    return crypto.createHash('sha256').update(token).digest('hex').substring(0, 16)
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:   * List available models for a token
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:   * @param {string} accessToken - User's access token
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        max_output_tokens: '4096',
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:    const tokenValidation = await this.validateToken(accessToken)
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:    if (!tokenValidation.allowedModels.includes('*')) {
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      params.push(tokenValidation.allowedModels)
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:   * Get token usage statistics
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:   * @param {string} accessToken - User's access token
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:    const tokenValidation = await this.validateToken(accessToken)
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:    const params = [tokenValidation.tokenId]
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        SUM(total_tokens) as total_tokens,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        SUM(prompt_tokens) as prompt_tokens,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:        SUM(completion_tokens) as completion_tokens,
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      FROM ai_token_usage
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:      WHERE access_token_id = $1 ${dateFilter}
./backend/monolith/src/core/TokenBasedLLMCoordinator.js:    this.tokenCache.clear()
./backend/monolith/src/core/LLMCoordinator.js:        tokensPerMinute: config.rateLimit?.tokensPerMinute || 100000
./backend/monolith/src/core/LLMCoordinator.js:      tokens: []
./backend/monolith/src/core/LLMCoordinator.js:            max_tokens: maxTokens,
./backend/monolith/src/core/LLMCoordinator.js:            prompt_tokens: response.usage.input_tokens,
./backend/monolith/src/core/LLMCoordinator.js:            completion_tokens: response.usage.output_tokens,
./backend/monolith/src/core/LLMCoordinator.js:            total_tokens: response.usage.input_tokens + response.usage.output_tokens
./backend/monolith/src/core/LLMCoordinator.js:            max_tokens: maxTokens,
./backend/monolith/src/core/LLMCoordinator.js:        this.metrics.totalTokens += result.usage.total_tokens
./backend/monolith/src/core/LLMCoordinator.js:    this.rateLimitState.tokens = this.rateLimitState.tokens.filter(
./backend/monolith/src/core/LLMCoordinator.js:    // Check token limit
./backend/monolith/src/core/LLMCoordinator.js:    const tokenSum = this.rateLimitState.tokens.reduce(
./backend/monolith/src/core/LLMCoordinator.js:      (sum, entry) => sum + entry.tokens,
./backend/monolith/src/core/LLMCoordinator.js:    if (tokenSum + estimatedTokens >= this.config.rateLimit.tokensPerMinute) {
./backend/monolith/src/core/LLMCoordinator.js:        60000 - (now - this.rateLimitState.tokens[0].timestamp)
./backend/monolith/src/core/LLMCoordinator.js:    this.rateLimitState.tokens.push({ timestamp: now, tokens: estimatedTokens })
./backend/monolith/src/core/LLMCoordinator.js:   * Get cache key
./backend/monolith/src/core/LLMCoordinator.js:  _getFromCache(key) {
./backend/monolith/src/core/LLMCoordinator.js:    const entry = this.cache.get(key)
./backend/monolith/src/core/LLMCoordinator.js:      this.cache.delete(key)
./backend/monolith/src/core/LLMCoordinator.js:  _setCache(key, value) {
./backend/monolith/src/core/LLMCoordinator.js:    this.cache.set(key, {
./backend/monolith/src/core/LLMCoordinator.js:      for (const [key, entry] of this.cache.entries()) {
./backend/monolith/src/core/LLMCoordinator.js:          this.cache.delete(key)
./backend/monolith/src/core/LLMCoordinator.js:    for (const [key, value] of Object.entries(variables)) {
./backend/monolith/src/core/LLMCoordinator.js:      rendered = rendered.replace(new RegExp(`{${key}}`, 'g'), value)
./backend/monolith/src/core/AgentContext.js:  setState(key, value) {
./backend/monolith/src/core/AgentContext.js:    this.sharedState.set(key, value)
./backend/monolith/src/core/AgentContext.js:    this.emit('state:changed', { key, value })
./backend/monolith/src/core/AgentContext.js:  getState(key) {
./backend/monolith/src/core/AgentContext.js:    return this.sharedState.get(key)
./backend/monolith/src/core/AgentContext.js:   * Check if shared state has key
./backend/monolith/src/core/AgentContext.js:  hasState(key) {
./backend/monolith/src/core/AgentContext.js:    return this.sharedState.has(key)
./backend/monolith/src/core/AgentContext.js:  deleteState(key) {
./backend/monolith/src/core/AgentContext.js:    this.sharedState.delete(key)
./backend/monolith/src/core/AgentContext.js:    this.emit('state:deleted', { key })
./backend/monolith/src/core/__tests__/LLMCoordinator.spec.js:      apiKey: 'test-key',
./backend/monolith/src/core/__tests__/LLMCoordinator.spec.js:      rateLimit: { requestsPerMinute: 100, tokensPerMinute: 10000 }
./backend/monolith/src/core/__tests__/LLMCoordinator.spec.js:      usage: { total_tokens: 50 },
./backend/monolith/src/core/__tests__/LLMCoordinator.spec.js:      usage: { total_tokens: 50 },
./backend/monolith/src/core/__tests__/LLMCoordinator.spec.js:      usage: { total_tokens: 100 },
./backend/monolith/src/core/__tests__/LLMCoordinator.spec.js:        usage: { total_tokens: 50 },
./backend/monolith/src/core/__tests__/LLMCoordinator.spec.js:      usage: { total_tokens: 50 },
./backend/monolith/src/core/MessageQueue.js:    this.maxStorageSize = options.maxStorageSize || 100000; // Max key-value pairs
./backend/monolith/src/core/MessageQueue.js:    // In-memory storage for key-value pairs
./backend/monolith/src/core/MessageQueue.js:    // TTL timers for expiring keys
./backend/monolith/src/core/MessageQueue.js:   * Set a key with optional expiration
./backend/monolith/src/core/MessageQueue.js:  async set(key, value, ttl = null) {
./backend/monolith/src/core/MessageQueue.js:      // Enforce storage size limit - remove oldest key if full
./backend/monolith/src/core/MessageQueue.js:      if (this.storage.size >= this.maxStorageSize && !this.storage.has(key)) {
./backend/monolith/src/core/MessageQueue.js:        const firstKey = this.storage.keys().next().value;
./backend/monolith/src/core/MessageQueue.js:        // Also clear TTL timer for removed key
./backend/monolith/src/core/MessageQueue.js:        }, 'Storage size limit reached, removing oldest key');
./backend/monolith/src/core/MessageQueue.js:      this.storage.set(key, value);
./backend/monolith/src/core/MessageQueue.js:      if (this.ttlTimers.has(key)) {
./backend/monolith/src/core/MessageQueue.js:        clearTimeout(this.ttlTimers.get(key));
./backend/monolith/src/core/MessageQueue.js:        this.ttlTimers.delete(key);
./backend/monolith/src/core/MessageQueue.js:          this.storage.delete(key);
./backend/monolith/src/core/MessageQueue.js:          this.ttlTimers.delete(key);
./backend/monolith/src/core/MessageQueue.js:          logger.debug({ key }, 'Key expired');
./backend/monolith/src/core/MessageQueue.js:        this.ttlTimers.set(key, timer);
./backend/monolith/src/core/MessageQueue.js:      logger.error({ key, error: error.message }, 'Failed to set key');
./backend/monolith/src/core/MessageQueue.js:   * Get a key
./backend/monolith/src/core/MessageQueue.js:  async get(key) {
./backend/monolith/src/core/MessageQueue.js:      return this.storage.get(key) || null;
./backend/monolith/src/core/MessageQueue.js:      logger.error({ key, error: error.message }, 'Failed to get key');
./backend/monolith/src/core/MessageQueue.js:   * Delete a key
./backend/monolith/src/core/MessageQueue.js:  async delete(key) {
./backend/monolith/src/core/MessageQueue.js:      if (this.ttlTimers.has(key)) {
./backend/monolith/src/core/MessageQueue.js:        clearTimeout(this.ttlTimers.get(key));
./backend/monolith/src/core/MessageQueue.js:        this.ttlTimers.delete(key);
./backend/monolith/src/core/MessageQueue.js:      this.storage.delete(key);
./backend/monolith/src/core/MessageQueue.js:      logger.error({ key, error: error.message }, 'Failed to delete key');
./backend/monolith/src/core/providers/AnthropicProvider.js:      max_tokens: options.maxTokens ?? 4096,
./backend/monolith/src/core/providers/AnthropicProvider.js:        promptTokens: response.usage?.input_tokens || 0,
./backend/monolith/src/core/providers/AnthropicProvider.js:        completionTokens: response.usage?.output_tokens || 0,
./backend/monolith/src/core/providers/AnthropicProvider.js:        totalTokens: (response.usage?.input_tokens || 0) + (response.usage?.output_tokens || 0)
./backend/monolith/src/core/providers/AnthropicProvider.js:        promptTokens: usage.input_tokens || 0,
./backend/monolith/src/core/providers/AnthropicProvider.js:        completionTokens: usage.output_tokens || 0,
./backend/monolith/src/core/providers/AnthropicProvider.js:        totalTokens: (usage.input_tokens || 0) + (usage.output_tokens || 0)
./backend/monolith/src/core/providers/AnthropicProvider.js:        promptTokens: usage.input_tokens || 0,
./backend/monolith/src/core/providers/AnthropicProvider.js:        completionTokens: usage.output_tokens || 0,
./backend/monolith/src/core/providers/AnthropicProvider.js:        totalTokens: (usage.input_tokens || 0) + (usage.output_tokens || 0)
./backend/monolith/src/core/providers/DeepSeekProvider.js:      max_tokens: options.maxTokens ?? 4096,
./backend/monolith/src/core/providers/DeepSeekProvider.js:        promptTokens: response.usage?.prompt_tokens || 0,
./backend/monolith/src/core/providers/DeepSeekProvider.js:        completionTokens: response.usage?.completion_tokens || 0,
./backend/monolith/src/core/providers/DeepSeekProvider.js:        totalTokens: response.usage?.total_tokens || 0
./backend/monolith/src/core/providers/DeepSeekProvider.js:        promptTokens: usage.prompt_tokens || 0,
./backend/monolith/src/core/providers/DeepSeekProvider.js:        completionTokens: usage.completion_tokens || 0,
./backend/monolith/src/core/providers/DeepSeekProvider.js:        totalTokens: usage.total_tokens || 0
./backend/monolith/src/core/providers/DeepSeekProvider.js:        promptTokens: usage.prompt_tokens || 0,
./backend/monolith/src/core/providers/DeepSeekProvider.js:        completionTokens: usage.completion_tokens || 0,
./backend/monolith/src/core/providers/DeepSeekProvider.js:        totalTokens: usage.total_tokens || 0
./backend/monolith/src/core/providers/KodacodeProvider.js: * Supports token rotation on rate limit (429) errors
./backend/monolith/src/core/providers/KodacodeProvider.js:    // Parse multiple tokens from KODACODE_TOKENS env var
./backend/monolith/src/core/providers/KodacodeProvider.js:    const tokensEnv = process.env.KODACODE_TOKENS || ''
./backend/monolith/src/core/providers/KodacodeProvider.js:    this.tokens = tokensEnv.split(',').map(t => t.trim()).filter(Boolean)
./backend/monolith/src/core/providers/KodacodeProvider.js:    // Add primary token if provided
./backend/monolith/src/core/providers/KodacodeProvider.js:    if (config.apiKey && !this.tokens.includes(config.apiKey)) {
./backend/monolith/src/core/providers/KodacodeProvider.js:      this.tokens.unshift(config.apiKey)
./backend/monolith/src/core/providers/KodacodeProvider.js:    // Fallback to GITHUB_TOKEN if no tokens
./backend/monolith/src/core/providers/KodacodeProvider.js:    if (this.tokens.length === 0 && process.env.GITHUB_TOKEN) {
./backend/monolith/src/core/providers/KodacodeProvider.js:      this.tokens.push(process.env.GITHUB_TOKEN)
./backend/monolith/src/core/providers/KodacodeProvider.js:    const token = this.tokens[this.currentTokenIndex]
./backend/monolith/src/core/providers/KodacodeProvider.js:      apiKey: token,
./backend/monolith/src/core/providers/KodacodeProvider.js:    if (this.tokens.length <= 1) {
./backend/monolith/src/core/providers/KodacodeProvider.js:      return false // No tokens to rotate to
./backend/monolith/src/core/providers/KodacodeProvider.js:    this.currentTokenIndex = (this.currentTokenIndex + 1) % this.tokens.length
./backend/monolith/src/core/providers/KodacodeProvider.js:    console.log(`[KodacodeProvider] Rotated token: ${oldIndex} -> ${this.currentTokenIndex}`)
./backend/monolith/src/core/providers/KodacodeProvider.js:    const maxRetries = this.tokens.length
./backend/monolith/src/core/providers/KodacodeProvider.js:          console.log(`[KodacodeProvider] Rate limit hit (status ${error.status}), trying next token (attempt ${attempt + 1}/${maxRetries})`)
./backend/monolith/src/core/providers/KodacodeProvider.js:        // Not a rate limit error or no more tokens
./backend/monolith/src/core/providers/KodacodeProvider.js:        console.log(`[KodacodeProvider] No more tokens to try or not a rate limit error`)
./backend/monolith/src/core/providers/KodacodeProvider.js:      max_tokens: options.maxTokens ?? 4096
./backend/monolith/src/core/providers/KodacodeProvider.js:        promptTokens: response.usage?.prompt_tokens || 0,
./backend/monolith/src/core/providers/KodacodeProvider.js:        completionTokens: response.usage?.completion_tokens || 0,
./backend/monolith/src/core/providers/KodacodeProvider.js:        totalTokens: response.usage?.total_tokens || 0,
./backend/monolith/src/core/providers/KodacodeProvider.js:        promptTokens: usage.prompt_tokens || 0,
./backend/monolith/src/core/providers/KodacodeProvider.js:        completionTokens: usage.completion_tokens || 0,
./backend/monolith/src/core/providers/KodacodeProvider.js:        totalTokens: usage.total_tokens || 0,
./backend/monolith/src/core/providers/KodacodeProvider.js:        promptTokens: usage.prompt_tokens || 0,
./backend/monolith/src/core/providers/KodacodeProvider.js:        completionTokens: usage.completion_tokens || 0,
./backend/monolith/src/core/providers/KodacodeProvider.js:        totalTokens: usage.total_tokens || 0,
./backend/monolith/src/core/providers/OpenAIProvider.js:      max_tokens: options.maxTokens ?? 4096,
./backend/monolith/src/core/providers/OpenAIProvider.js:        promptTokens: response.usage?.prompt_tokens || 0,
./backend/monolith/src/core/providers/OpenAIProvider.js:        completionTokens: response.usage?.completion_tokens || 0,
./backend/monolith/src/core/providers/OpenAIProvider.js:        totalTokens: response.usage?.total_tokens || 0
./backend/monolith/src/core/providers/OpenAIProvider.js:        promptTokens: usage.prompt_tokens || 0,
./backend/monolith/src/core/providers/OpenAIProvider.js:        completionTokens: usage.completion_tokens || 0,
./backend/monolith/src/core/providers/OpenAIProvider.js:        totalTokens: usage.total_tokens || 0
./backend/monolith/src/core/providers/OpenAIProvider.js:        promptTokens: usage.prompt_tokens || 0,
./backend/monolith/src/core/providers/OpenAIProvider.js:        completionTokens: usage.completion_tokens || 0,
./backend/monolith/src/core/providers/OpenAIProvider.js:        totalTokens: usage.total_tokens || 0
./backend/monolith/src/core/providers/PolzaProvider.js:      max_tokens: options.maxTokens ?? 4096
./backend/monolith/src/core/providers/PolzaProvider.js:        promptTokens: response.usage?.prompt_tokens || 0,
./backend/monolith/src/core/providers/PolzaProvider.js:        completionTokens: response.usage?.completion_tokens || 0,
./backend/monolith/src/core/providers/PolzaProvider.js:        totalTokens: response.usage?.total_tokens || 0,
./backend/monolith/.env.example:SSL_KEY_PATH=/etc/letsencrypt/live/drondoc.ru/privkey.pem
./backend/monolith/.env.example:# SSL_KEY_PATH=/path/to/your/key.pem
./backend/monolith/.env.example:DATABASE_URL=postgresql://user:password@localhost:5432/dronedoc
./backend/monolith/.env.example:DB_PASSWORD=your-db-password
./backend/monolith/.env.example:# Get your DeepSeek API key at: https://platform.deepseek.com/api_keys
./backend/monolith/.env.example:# Issue #4722: At least ONE of these keys must be configured for workspace chat to work
./backend/monolith/.env.example:# If none are set, workspace chat will fail with "No AI provider API keys configured" error
./backend/monolith/.env.example:POLZA_AI_API_KEY=your-polza-api-key
./backend/monolith/.env.example:OPENAI_API_KEY=your-openai-api-key
./backend/monolith/.env.example:DEEPSEEK_API_KEY=your-deepseek-api-key
./backend/monolith/.env.example:ANTHROPIC_API_KEY=your-anthropic-api-key
./backend/monolith/.env.example:# Get your Tavily API key at: https://tavily.com/
./backend/monolith/.env.example:TAVILY_API_KEY=your-tavily-api-key
./backend/monolith/.env.example:#CLAUDE_SSH_PASSWORD=your-ssh-password
./backend/monolith/.env.example:# 1. Unified token storage (ai_provider_api_keys table) - preferred for production
./backend/monolith/.env.example:#    Add it via: POST /api/ai-tokens/provider-keys with providerName='dronedoc'
./backend/monolith/.env.example:DRONEDOC_AUTH_TOKEN=your-dronedoc-auth-token
./backend/monolith/.env.example:YOUTUBE_API_KEY=your-youtube-api-key
./backend/monolith/.env.example:TELEGRAM_BOT_TOKEN=your-telegram-bot-token
./backend/monolith/.env.example:# SMTP settings for sending verification emails, password resets, etc.
./backend/monolith/.env.example:SMTP_PASSWORD=your-app-password
./backend/monolith/.env.example:STRIPE_API_KEY=your-stripe-api-key
./backend/monolith/.env.example:STRIPE_WEBHOOK_SECRET=your-webhook-secret
./backend/monolith/.env.example:LAVA_API_KEY=your-lava-api-key
./backend/monolith/.env.example:ROBOKASSA_PASSWORD_1=your-password-1
./backend/monolith/.env.example:ROBOKASSA_PASSWORD_2=your-password-2
./backend/monolith/.env.example:YOOKASSA_SECRET_KEY=your-secret-key
./backend/monolith/.env.example:TINKOFF_TERMINAL_KEY=your-terminal-key
./backend/monolith/.env.example:TINKOFF_SECRET_KEY=your-secret-key
./backend/monolith/.env.example:TOCHKA_CLIENT_SECRET=your-client-secret
./backend/monolith/.env.example:# CRITICAL: Generate strong secrets before deploying to production!
./backend/monolith/.env.example:# Run: node scripts/generate-jwt-secret.js
./backend/monolith/.env.example:# JWT_SECRET: Used for signing JWT tokens (must be at least 64 characters / 256 bits)
./backend/monolith/.env.example:# NEVER use weak values like 'secret', 'password', or 'changeme'
./backend/monolith/.env.example:# NEVER commit real secrets to git
./backend/monolith/.env.example:# Use different secrets for development and production
./backend/monolith/.env.example:JWT_SECRET=your-jwt-secret-generate-with-script
./backend/monolith/.env.example:SESSION_SECRET=your-session-secret-generate-with-script
./backend/monolith/.env.example:# Access tokens: short-lived (15 minutes recommended)
./backend/monolith/.env.example:# Refresh tokens: long-lived (7 days recommended)
./backend/monolith/.env.example:# Note: GitHub API token can be stored in two ways:
./backend/monolith/.env.example:# 1. Unified token storage (ai_provider_api_keys table) - preferred for production
./backend/monolith/.env.example:#    Add it via: POST /api/ai-tokens/provider-keys with providerName='github'
./backend/monolith/.env.example:GITHUB_TOKEN=your-github-token
./backend/monolith/.env.example:# SSH key authentication must be configured (no password)
./backend/monolith/.env.example:BACKUP_ENCRYPTION_KEY=your-256-bit-encryption-key-change-this-in-production
./backend/monolith/.env.example:# Generate a strong random secret: openssl rand -hex 32
./backend/monolith/.env.example:# Configure this same secret in GitHub repository settings:
./backend/monolith/.env.example:GITHUB_WEBHOOK_SECRET=your-webhook-secret-change-me-in-production
./src/services/tokenService.js: * Provides token management services using the unified token API
./src/services/tokenService.js: * from Phase 2 (backend/monolith/src/api/routes/ai-tokens.js)
./src/services/tokenService.js: * - Get user's AI tokens
./src/services/tokenService.js: * - Create new AI tokens
./src/services/tokenService.js: * - Get token usage statistics
./src/services/tokenService.js: * - Track token operations
./src/services/tokenService.js: * - Manage token balance and limits
./src/services/tokenService.js: * Get all tokens for current user
./src/services/tokenService.js: * @param {string} accessToken - User's access token (JWT)
./src/services/tokenService.js: * @returns {Promise<Array>} List of user's AI tokens
./src/services/tokenService.js:    logger.info('Fetching user tokens')
./src/services/tokenService.js:    const response = await axios.get(`${API_BASE}/ai-tokens/my-tokens`, {
./src/services/tokenService.js:      throw new Error(response.data.error || 'Failed to fetch tokens')
./src/services/tokenService.js:    const tokens = response.data.data
./src/services/tokenService.js:    logger.info('User tokens fetched', { count: tokens.length })
./src/services/tokenService.js:    return tokens
./src/services/tokenService.js:    logger.error('Failed to fetch user tokens', {
./src/services/tokenService.js:    throw new Error(error.response?.data?.error || error.message || 'Failed to fetch tokens')
./src/services/tokenService.js: * Get default token for current user
./src/services/tokenService.js: * Each user automatically gets a default token on registration
./src/services/tokenService.js: * @param {string} accessToken - User's access token (JWT)
./src/services/tokenService.js: * @returns {Promise<Object>} Default token with model info
./src/services/tokenService.js:    logger.info('Fetching default token')
./src/services/tokenService.js:    const response = await axios.get(`${API_BASE}/ai-tokens/default-token`, {
./src/services/tokenService.js:      throw new Error(response.data.error || 'Failed to fetch default token')
./src/services/tokenService.js:    logger.info('Default token fetched', {
./src/services/tokenService.js:      tokenId: data.token.id,
./src/services/tokenService.js:      token: data.token,
./src/services/tokenService.js:    logger.error('Failed to fetch default token', {
./src/services/tokenService.js:    throw new Error(error.response?.data?.error || error.message || 'Failed to fetch default token')
./src/services/tokenService.js: * Create new AI token
./src/services/tokenService.js: * @param {Object} tokenData - Token configuration
./src/services/tokenService.js: * @param {string} tokenData.provider - Provider name (deepseek, openai, etc.)
./src/services/tokenService.js: * @param {string} tokenData.model - Model name
./src/services/tokenService.js: * @param {number} [tokenData.balance] - Initial balance (default: 1000000)
./src/services/tokenService.js: * @param {number} [tokenData.dailyLimit] - Daily limit (default: 100000)
./src/services/tokenService.js: * @param {number} [tokenData.monthlyLimit] - Monthly limit (default: 1000000)
./src/services/tokenService.js: * @param {string} [tokenData.name] - Token name (optional)
./src/services/tokenService.js: * @param {string} accessToken - User's access token (JWT)
./src/services/tokenService.js: * @returns {Promise<Object>} Created token data
./src/services/tokenService.js:export async function createToken(tokenData, accessToken) {
./src/services/tokenService.js:    logger.info('Creating new token', {
./src/services/tokenService.js:      provider: tokenData.provider,
./src/services/tokenService.js:      model: tokenData.model
./src/services/tokenService.js:      `${API_BASE}/ai-tokens/create`,
./src/services/tokenService.js:        provider: tokenData.provider,
./src/services/tokenService.js:        model: tokenData.model,
./src/services/tokenService.js:        balance: tokenData.balance || 1000000,
./src/services/tokenService.js:        dailyLimit: tokenData.dailyLimit || 100000,
./src/services/tokenService.js:        monthlyLimit: tokenData.monthlyLimit || 1000000,
./src/services/tokenService.js:        name: tokenData.name
./src/services/tokenService.js:      throw new Error(response.data.error || 'Failed to create token')
./src/services/tokenService.js:    const token = response.data.data
./src/services/tokenService.js:      tokenId: token.id,
./src/services/tokenService.js:      tokenPrefix: token.token_prefix
./src/services/tokenService.js:    return token
./src/services/tokenService.js:    logger.error('Failed to create token', {
./src/services/tokenService.js:      provider: tokenData.provider
./src/services/tokenService.js:    throw new Error(error.response?.data?.error || error.message || 'Failed to create token')
./src/services/tokenService.js: * Get usage statistics for a token
./src/services/tokenService.js: * @param {string} tokenId - Token ID (dd_tok_xxx)
./src/services/tokenService.js: * @param {string} accessToken - User's access token (JWT)
./src/services/tokenService.js:export async function getUsageStats(tokenId, period = 'month', accessToken) {
./src/services/tokenService.js:    logger.info('Fetching usage statistics', { tokenId, period })
./src/services/tokenService.js:    const response = await axios.get(`${API_BASE}/ai-tokens/usage/${tokenId}`, {
./src/services/tokenService.js:      tokenId,
./src/services/tokenService.js:      tokenId,
./src/services/tokenService.js: * Get detailed usage logs for a token
./src/services/tokenService.js: * @param {string} tokenId - Token ID (dd_tok_xxx)
./src/services/tokenService.js: * @param {string} accessToken - User's access token (JWT)
./src/services/tokenService.js:export async function getUsageLogs(tokenId, options = {}, accessToken) {
./src/services/tokenService.js:    logger.info('Fetching usage logs', { tokenId, options })
./src/services/tokenService.js:    const response = await axios.get(`${API_BASE}/ai-tokens/usage-logs/${tokenId}`, {
./src/services/tokenService.js:      tokenId,
./src/services/tokenService.js:      tokenId,
./src/services/tokenService.js: * Update token limits
./src/services/tokenService.js: * @param {string} tokenId - Token ID (dd_tok_xxx)
./src/services/tokenService.js: * @param {string} accessToken - User's access token (JWT)
./src/services/tokenService.js: * @returns {Promise<Object>} Updated token
./src/services/tokenService.js:export async function updateTokenLimits(tokenId, limits, accessToken) {
./src/services/tokenService.js:    logger.info('Updating token limits', { tokenId, limits })
./src/services/tokenService.js:      `${API_BASE}/ai-tokens/${tokenId}/limits`,
./src/services/tokenService.js:      throw new Error(response.data.error || 'Failed to update token limits')
./src/services/tokenService.js:    const token = response.data.data
./src/services/tokenService.js:    logger.info('Token limits updated successfully', { tokenId })
./src/services/tokenService.js:    return token
./src/services/tokenService.js:    logger.error('Failed to update token limits', {
./src/services/tokenService.js:      tokenId,
./src/services/tokenService.js:    throw new Error(error.response?.data?.error || error.message || 'Failed to update token limits')
./src/services/tokenService.js: * Revoke (delete) a token
./src/services/tokenService.js: * @param {string} tokenId - Token ID (dd_tok_xxx)
./src/services/tokenService.js: * @param {string} accessToken - User's access token (JWT)
./src/services/tokenService.js:export async function revokeToken(tokenId, accessToken) {
./src/services/tokenService.js:    logger.info('Revoking token', { tokenId })
./src/services/tokenService.js:    const response = await axios.delete(`${API_BASE}/ai-tokens/${tokenId}`, {
./src/services/tokenService.js:      throw new Error(response.data.error || 'Failed to revoke token')
./src/services/tokenService.js:    logger.info('Token revoked successfully', { tokenId })
./src/services/tokenService.js:    logger.error('Failed to revoke token', {
./src/services/tokenService.js:      tokenId,
./src/services/tokenService.js:    throw new Error(error.response?.data?.error || error.message || 'Failed to revoke token')
./src/services/tokenService.js: * @param {string} [accessToken] - User's access token (optional)
./src/services/tokenService.js:    const response = await axios.get(`${API_BASE}/ai-tokens/models`, {
./src/services/tokenService.js: * @param {string} [accessToken] - User's access token (optional)
./src/services/tokenService.js:    const response = await axios.get(`${API_BASE}/ai-tokens/providers`, {
./src/services/tokenService.js: * Perform AI operation with token
./src/services/tokenService.js: * @param {string} tokenId - Token ID (dd_tok_xxx)
./src/services/tokenService.js: * @param {string} accessToken - User's access token (JWT)
./src/services/tokenService.js:export async function performAIOperation(tokenId, operation, accessToken) {
./src/services/tokenService.js:      tokenId,
./src/services/tokenService.js:      `${API_BASE}/ai-tokens/chat`,
./src/services/tokenService.js:        tokenId,
./src/services/tokenService.js:      tokenId,
./src/services/tokenService.js:      tokensUsed: result.usage?.totalTokens
./src/services/tokenService.js:      tokenId,
./src/services/tokenService.js: * Get user's balance (total token balance across all tokens)
./src/services/tokenService.js: * @param {string} accessToken - User's access token (JWT)
./src/services/tokenService.js: * @returns {Promise<number>} Total balance in tokens
./src/services/tokenService.js:    const response = await axios.get(`${API_BASE}/ai-tokens/balance`, {
./src/services/tokenService.js:    // If endpoint doesn't exist yet, try to get from default token
./src/services/tokenService.js:      const { token } = await getDefaultToken(accessToken)
./src/services/tokenService.js:      return token.token_balance || 0
./src/services/tokenService.js:      logger.warn('Fallback to default token failed, returning 0', { error: fallbackError.message })
./src/services/tokenService.js: * Get token usage aggregate for a user/period (compat function for Tokens.vue)
./src/services/tokenService.js:    const token = getAuthToken()
./src/services/tokenService.js:    if (token) headers['Authorization'] = `Bearer ${token}`
./src/services/tokenService.js:    const { data } = await axios.get(`${API_BASE}/ai-tokens/usage`, { params, headers })
./src/services/tokenService.js:      throw new Error(data?.error || 'Failed to fetch token usage')
./src/services/tokenService.js: * Get token usage history (compat function for Tokens.vue)
./src/services/tokenService.js:    const token = getAuthToken()
./src/services/tokenService.js:    if (token) headers['Authorization'] = `Bearer ${token}`
./src/services/tokenService.js:    const { data } = await axios.get(`${API_BASE}/ai-tokens/usage`, { params, headers })
./src/services/tokenService.js:// Internal: fetch bearer token from storage if present
./src/services/tokenService.js:    localStorage.getItem('auth_token') ||
./src/services/tokenService.js:    sessionStorage.getItem('auth_token') ||
./src/services/tokenService.js:    localStorage.getItem('access_token') ||
./src/i18n/locales/ru.js:      passwordProtect: '–ó–∞—â–∏—â–∞—Ç—å –ø–∞—Ä–æ–ª–µ–º',
./src/i18n/locales/ru.js:    password: '–ü–∞—Ä–æ–ª—å',
./src/i18n/locales/ru.js:    passwordMatch: '–ü–∞—Ä–æ–ª–∏ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç',
./src/i18n/locales/ru.js:    keyName: '–ù–∞–∑–≤–∞–Ω–∏–µ –∫–ª—é—á–∞',
./src/i18n/locales/ru.js:        password: '–ü–∞—Ä–æ–ª—å'
./src/i18n/locales/ru.js:        secretHelp: '–°–µ–∫—Ä–µ—Ç—ã —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ–º —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏',
./src/i18n/locales/ru.js:        secret: '–°–µ–∫—Ä–µ—Ç'
./src/i18n/locales/ru.js:    tokenDialog: {
./src/i18n/locales/ru.js:      dbPasswordPlaceholder: 'password',
./src/i18n/locales/ru.js:      tokensTable: 'ID —Ç–∞–±–ª–∏—Ü—ã —Ç–æ–∫–µ–Ω–æ–≤',
./src/i18n/locales/ru.js:      tokensTablePlaceholder: 'ID —Ç–∏–ø–∞ —Ç–æ–∫–µ–Ω–∞',
./src/i18n/locales/ru.js:      tokensTableHelp: 'ID —Ç–∞–±–ª–∏—Ü—ã Integram –¥–ª—è —Ç–æ–∫–µ–Ω–æ–≤',
./src/i18n/locales/ru.js:    tokenManagement: {
./src/i18n/locales/ru.js:    tokenForm: {
./src/i18n/locales/ru.js:      placeholder: '[{"name": "My Token", "tokenValue": "...", ...}]',
./src/i18n/locales/ru.js:      tokenAdded: '–¢–æ–∫–µ–Ω –¥–æ–±–∞–≤–ª–µ–Ω',
./src/i18n/locales/ru.js:      tokenUpdated: '–¢–æ–∫–µ–Ω –æ–±–Ω–æ–≤–ª–µ–Ω',
./src/i18n/locales/ru.js:      tokenDeleted: '–¢–æ–∫–µ–Ω —É–¥–∞–ª–µ–Ω',
./src/i18n/locales/ru.js:      tokenSetDefault: '–¢–æ–∫–µ–Ω —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é',
./src/i18n/locales/ru.js:      tokensExported: '–¢–æ–∫–µ–Ω—ã —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã',
./src/i18n/locales/ru.js:      tokensImported: '–ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ —Ç–æ–∫–µ–Ω–æ–≤:',
./src/i18n/locales/ru.js:      tokensCleared: '–í—Å–µ —Ç–æ–∫–µ–Ω—ã —É–¥–∞–ª–µ–Ω—ã',
./src/i18n/locales/ru.js:      tokenError: '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç–æ–∫–µ–Ω',
./src/i18n/locales/ru.js:      keywords: '–∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä ROI AI-–∞–≥–µ–Ω—Ç–æ–≤, ROI –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏, –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä —ç–∫–æ–Ω–æ–º–∏–∏ –≤—Ä–µ–º–µ–Ω–∏, –∞–Ω–∞–ª–∏–∑ –≤–ª–∏—è–Ω–∏—è –Ω–∞ –±–∏–∑–Ω–µ—Å, –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏'
./src/i18n/locales/ru.js:    keyInsights: {
./src/i18n/locales/ru.js:    // IDE layout keys
./src/i18n/locales/ru.js:    keyIdeas: '–ö–ª—é—á–µ–≤—ã–µ –∏–¥–µ–∏',
./src/i18n/locales/en.js:      passwordProtect: 'Password protect',
./src/i18n/locales/en.js:    password: 'Password',
./src/i18n/locales/en.js:    passwordMatch: 'Passwords do not match',
./src/i18n/locales/en.js:    maxTokens: 'Max tokens',
./src/i18n/locales/en.js:    createNew: 'Create new key',
./src/i18n/locales/en.js:    keyName: 'Key Name',
./src/i18n/locales/en.js:    confirmDelete: 'Are you sure you want to delete this API key?',
./src/i18n/locales/en.js:    confirmRevoke: 'Are you sure you want to revoke this API key?',
./src/i18n/locales/en.js:        password: 'Password'
./src/i18n/locales/en.js:        selectSecretPlaceholder: 'Choose an existing secret',
./src/i18n/locales/en.js:        secretHelp: 'Secrets are stored in organization secure vault',
./src/i18n/locales/en.js:        noSecrets: 'No available secrets. Create a secret in organization settings.'
./src/i18n/locales/en.js:        secret: 'Secret'
./src/i18n/locales/en.js:    tokenDialog: {
./src/i18n/locales/en.js:      dbPasswordPlaceholder: 'password',
./src/i18n/locales/en.js:      jwtSecretPlaceholder: 'JWT secret for token signing',
./src/i18n/locales/en.js:      jwtSecretHelp: 'Secret key for JWT token signing and verification',
./src/i18n/locales/en.js:      adminPasswordHelp: 'Admin password for ddadmin database',
./src/i18n/locales/en.js:      tokensTable: 'Tokens Table ID',
./src/i18n/locales/en.js:      tokensTablePlaceholder: 'Token type ID',
./src/i18n/locales/en.js:      tokensTableHelp: 'Integram table ID for tokens',
./src/i18n/locales/en.js:    tokenManagement: {
./src/i18n/locales/en.js:      description: 'Store tokens locally in your browser for quick access. Tokens are encrypted before saving for security.',
./src/i18n/locales/en.js:      noTokens: 'No saved tokens',
./src/i18n/locales/en.js:      balance: 'tokens',
./src/i18n/locales/en.js:    tokenForm: {
./src/i18n/locales/en.js:      description: 'Paste JSON data of exported tokens:',
./src/i18n/locales/en.js:      placeholder: '[{"name": "My Token", "tokenValue": "...", ...}]',
./src/i18n/locales/en.js:          'Local token storage for all users'
./src/i18n/locales/en.js:      tokenAdded: 'Token Added',
./src/i18n/locales/en.js:      tokenUpdated: 'Token Updated',
./src/i18n/locales/en.js:      tokenDeleted: 'Token Deleted',
./src/i18n/locales/en.js:      tokenSetDefault: 'Token Set as Default',
./src/i18n/locales/en.js:      tokensExported: 'Tokens Exported',
./src/i18n/locales/en.js:      tokensImported: 'Tokens Imported:',
./src/i18n/locales/en.js:      tokensCleared: 'All Tokens Cleared',
./src/i18n/locales/en.js:      tokenError: 'Failed to save token',
./src/i18n/locales/en.js:      loadError: 'Failed to load tokens',
./src/i18n/locales/en.js:      deleteError: 'Failed to delete token',
./src/i18n/locales/en.js:      exportError: 'Failed to export tokens',
./src/i18n/locales/en.js:      importError: 'Failed to import tokens',
./src/i18n/locales/en.js:      clearError: 'Failed to clear tokens'
./src/i18n/locales/en.js:        message: 'Are you sure you want to delete this token?',
./src/i18n/locales/en.js:        message: 'Are you sure you want to delete ALL saved tokens? This action cannot be undone.',
./src/i18n/locales/en.js:      keywords: 'AI agents ROI calculator, automation ROI, time savings calculator, business impact analysis, productivity calculator'
./src/i18n/locales/en.js:    keyInsights: {
./src/i18n/locales/en.js:        description: 'Select a secret containing credentials for this data source',
./src/i18n/locales/en.js:        selectSecretPlaceholder: 'Choose from organization secrets',
./src/i18n/locales/en.js:        secretHelp: 'Credentials are securely stored in organization secrets',
./src/i18n/locales/en.js:        noSecrets: 'No secrets available. Create a secret in organization settings first.'
./src/i18n/locales/en.js:        secret: 'Secret'
./src/i18n/locales/en.js:    // IDE layout keys
./src/i18n/locales/en.js:    welcomeDescription: 'Select a file to edit or use keyboard shortcuts.',
./src/i18n/locales/en.js:    keyIdeas: 'Key Ideas',
./src/i18n/locales/zh.js:    password: 'ÂØÜÁ†Å',
./src/i18n/locales/zh.js:    passwordMismatch: 'ÂØÜÁ†Å‰∏çÂåπÈÖç',
./src/i18n/locales/zh.js:      dbPasswordPlaceholder: 'password',
./src/i18n/locales/zh.js:      tokensTable: '‰ª§ÁâåË°® ID',
./src/i18n/locales/zh.js:      tokensTablePlaceholder: '‰ª§ÁâåÁ±ªÂûã ID',
./src/i18n/locales/zh.js:      tokensTableHelp: '‰ª§ÁâåÁöÑ Integram Ë°® ID',
./src/i18n/locales/zh.js:      keywords: 'AI‰ª£ÁêÜÊäïËµÑÂõûÊä•ÁéáËÆ°ÁÆóÂô®, Ëá™Âä®ÂåñÊäïËµÑÂõûÊä•Áéá, Êó∂Èó¥ËäÇÁúÅËÆ°ÁÆóÂô®, ‰∏öÂä°ÂΩ±ÂìçÂàÜÊûê, Áîü‰∫ßÂäõËÆ°ÁÆóÂô®'
./src/i18n/locales/zh.js:    keyInsights: {
./src/i18n/locales/zh.js:        password: 'ÂØÜÁ†Å'
./src/i18n/locales/zh.js:        secretHelp: 'ÂØÜÈí•Â≠òÂÇ®Âú®ÁªÑÁªáÂÆâÂÖ®‰øùÁÆ°Â∫ì‰∏≠',
./src/i18n/locales/zh.js:        secret: 'ÂØÜÈí•'
./src/axios2.js: * Issue #3554: Updated to use Unified Authentication tokens
./src/axios2.js: * 3. Legacy token from localStorage
./src/axios2.js: * - Monolithic backend APIs (ai-tokens, youtube, recording, etc.)
./src/axios2.js: * Get token and authentication database
./src/axios2.js: * Issue #3848: Simplified authorization token storage system
./src/axios2.js: * Simplified token storage system:
./src/axios2.js: * 1. Single 'token' in localStorage for all databases ('my' and others)
./src/axios2.js: * 2. authDb determined from localStorage 'db' key (the database user logged into)
./src/axios2.js: * Issue #4140: Use localStorage token for 'my' header (not cookie)
./src/axios2.js: * The 'my' cookie may contain password instead of token, so always use localStorage token
./src/axios2.js:  const token = localStorage.getItem('token')
./src/axios2.js:  return { token, db: authDb }
./src/axios2.js:// Issue #3848: Simplified authorization with single token
./src/axios2.js:// Issue #4140: Use localStorage token for 'my' header (not cookie)
./src/axios2.js:    // Get token and authentication database (the database user logged into)
./src/axios2.js:    // Issue #4140: Use localStorage token only (removed myCookieToken)
./src/axios2.js:    const { token, db: authDb } = getTokenForCurrentDb()
./src/axios2.js:    // Issue #4140: Use localStorage token for 'my' header (not cookie)
./src/axios2.js:    //    - Requests to other databases (e.g., /a2025/) ‚Üí 'my' header with localStorage token
./src/axios2.js:        if (token) {
./src/axios2.js:          config.headers['X-Authorization'] = token
./src/axios2.js:        // Issue #4140: Use localStorage token (not cookie) as it contains the actual token
./src/axios2.js:        if (token) {
./src/axios2.js:          config.headers['my'] = token
./src/axios2.js:    } else if (token) {
./src/axios2.js:      config.headers['X-Authorization'] = token
./src/axios2.js:    // Issue #4140: Add debug logging to help diagnose token issues
./src/axios2.js:    if (!token) {
./src/axios2.js:      console.warn('[axios2] No token found in localStorage!', {
./src/axios2.js:        localStorageKeys: Object.keys(localStorage)
./src/axios2.js:      // Log token usage for debugging (only first/last 4 chars for security)
./src/axios2.js:      const tokenPreview = token.length > 8
./src/axios2.js:        ? `${token.substring(0, 4)}...${token.substring(token.length - 4)}`
./src/axios2.js:      //   tokenLength: token.length,
./src/axios2.js:      //   tokenPreview,
./src/axios2.js:        // Clear both legacy and new format tokens
./src/axios2.js:        localStorage.removeItem('token')
./src/router/helpers/routeFactory.js:    keywords = ''
./src/router/helpers/routeFactory.js:      seoKeywords: keywords
./src/router/guards/sessionGuards.js: * Clear all auth-related localStorage keys
./src/router/guards/sessionGuards.js:  const keysToRemove = [
./src/router/guards/sessionGuards.js:    '_xsrf', 'token', 'user', 'id', 'session_timestamp',
./src/router/guards/sessionGuards.js:    'accessToken', 'refreshToken', // Issue #5112: OAuth/JWT tokens
./src/router/guards/sessionGuards.js:    'ddadmin_token', 'ddadmin_user', 'ddadmin_id', 'ddadmin_xsrf',
./src/router/guards/sessionGuards.js:    'my_token', 'my_user', 'my_id', 'my_xsrf'
./src/router/guards/sessionGuards.js:  keysToRemove.forEach(key => localStorage.removeItem(key))
./src/router/guards/sessionGuards.js: * 1. Legacy localStorage keys (_xsrf, user) - used by main Login.vue
./src/router/guards/sessionGuards.js:  // OAuth callback stores: token, accessToken, user, id, session_timestamp
./src/router/guards/sessionGuards.js:      if (sessionData.token) {
./src/stores/authStore.js: * Issue #3848: Simplified authorization token storage system
./src/stores/authStore.js: * Simplified single token system:
./src/stores/authStore.js: * 1. Single 'token' in localStorage for all databases
./src/stores/authStore.js:    primaryToken.value = localStorage.getItem('token')
./src/stores/authStore.js:    ddadminToken.value = localStorage.getItem('ddadmin_token')
./src/stores/authStore.js:    myToken.value = localStorage.getItem('my_token')
./src/stores/authStore.js:          // Sync tokens to localStorage for backward compatibility
./src/stores/authStore.js:          // Session not found on server - just clear unified session, keep legacy tokens
./src/stores/authStore.js:        // Just clear unified session, don't touch legacy tokens
./src/stores/authStore.js:   * Sync unified session tokens to localStorage for backward compatibility
./src/stores/authStore.js:      // Sync primary database token
./src/stores/authStore.js:        primaryToken.value = dbToken.token
./src/stores/authStore.js:        localStorage.setItem('token', dbToken.token)
./src/stores/authStore.js:      // Sync ddadmin token
./src/stores/authStore.js:        ddadminToken.value = ddToken.token
./src/stores/authStore.js:        localStorage.setItem('ddadmin_token', ddToken.token)
./src/stores/authStore.js:      console.warn('[authStore] Failed to sync unified tokens:', err)
./src/stores/authStore.js:      // Don't clear legacy tokens - they may still be valid
./src/stores/authStore.js:    localStorage.removeItem('token')
./src/stores/authStore.js:    localStorage.removeItem('ddadmin_token')
./src/stores/authStore.js:    localStorage.removeItem('my_token')
./src/stores/authStore.js:    // Issue #5112: Clear OAuth/JWT tokens and session data
./src/stores/authStore.js:  async function authenticateToDatabase(login, password, apiBase, database) {
./src/stores/authStore.js:    formData.append('pwd', password)
./src/stores/authStore.js:    // API returns: { token, _xsrf, id, msg } on success
./src/stores/authStore.js:    if (!data.token) {
./src/stores/authStore.js:      token: data.token,
./src/stores/authStore.js:   * Issue #3848: Simplified single token system
./src/stores/authStore.js:   * 1. Single 'token' in localStorage for all databases
./src/stores/authStore.js:    password,
./src/stores/authStore.js:        password,
./src/stores/authStore.js:      // Issue #3848: Store SINGLE token for all databases
./src/stores/authStore.js:      // This token works for:
./src/stores/authStore.js:      primaryToken.value = primaryAuth.token
./src/stores/authStore.js:      // Issue #3848: Defensive token storage with verification
./src/stores/authStore.js:      // Save token to localStorage with retry and verification
./src/stores/authStore.js:      const tokenData = {
./src/stores/authStore.js:        token: primaryAuth.token,
./src/stores/authStore.js:      console.log('[authStore] Saving authentication tokens to localStorage', {
./src/stores/authStore.js:        hasToken: !!primaryAuth.token,
./src/stores/authStore.js:        tokenLength: primaryAuth.token?.length,
./src/stores/authStore.js:      for (const [key, value] of Object.entries(tokenData)) {
./src/stores/authStore.js:          localStorage.setItem(key, value)
./src/stores/authStore.js:          const savedValue = localStorage.getItem(key)
./src/stores/authStore.js:            console.error(`[authStore] Failed to save ${key} to localStorage. Expected: ${value}, Got: ${savedValue}`)
./src/stores/authStore.js:            throw new Error(`Failed to save ${key} to localStorage`)
./src/stores/authStore.js:          console.error(`[authStore] Error saving ${key} to localStorage:`, error)
./src/stores/authStore.js:      // Final verification that token exists in localStorage
./src/stores/authStore.js:      const verifiedToken = localStorage.getItem('token')
./src/stores/authStore.js:      if (!verifiedToken || verifiedToken !== primaryAuth.token) {
./src/stores/authStore.js:          expected: primaryAuth.token,
./src/stores/authStore.js:      console.log('[authStore] Authentication tokens saved successfully', {
./src/stores/authStore.js:        token: verifiedToken.substring(0, 10) + '...',
./src/stores/authStore.js:        token: primaryAuth.token,
./src/stores/authStore.js:      const finalVerification = localStorage.getItem('token')
./src/stores/authStore.js:          expected: primaryAuth.token,
./src/stores/authStore.js:      console.log('[authStore] Final verification passed, token persisted successfully')
./src/stores/authStore.js:   * Issue #3848: Simplified logout - clear single token
./src/stores/authStore.js:    // Issue #3848: Clear the single token system
./src/stores/authStore.js:    localStorage.removeItem('token')
./src/stores/authStore.js:    // Clear legacy tokens (backward compatibility)
./src/stores/authStore.js:    localStorage.removeItem('ddadmin_token')
./src/stores/authStore.js:    localStorage.removeItem('my_token')
./src/stores/authStore.js:    // Issue #5112: Clear OAuth/JWT tokens
./src/stores/authStore.js:   * Get token for any database from unified session
./src/stores/authStore.js:        const tokenData = await unifiedAuthService.getTokenForDatabase(database)
./src/stores/authStore.js:        if (tokenData) {
./src/stores/authStore.js:          return tokenData
./src/stores/authStore.js:        console.warn(`[authStore] Failed to get token for ${database} from unified auth:`, err)
./src/stores/authStore.js:      const token = ddadminToken.value || localStorage.getItem('ddadmin_token')
./src/stores/authStore.js:      if (token) {
./src/stores/authStore.js:          token,
./src/stores/authStore.js:        const token = primaryToken.value || localStorage.getItem('token')
./src/stores/authStore.js:        if (token) {
./src/stores/authStore.js:            token,
./src/stores/authStore.js:   * Get all available tokens
./src/stores/authStore.js:   * @returns {Promise<Object>} Map of database ‚Üí token data
./src/stores/authStore.js:        console.warn('[authStore] Failed to get all tokens from unified auth:', err)
./src/stores/authStore.js:    const tokens = {}
./src/stores/authStore.js:    const primaryTokenVal = primaryToken.value || localStorage.getItem('token')
./src/stores/authStore.js:      tokens[currentDb] = {
./src/stores/authStore.js:        token: primaryTokenVal,
./src/stores/authStore.js:    const ddadminTokenVal = ddadminToken.value || localStorage.getItem('ddadmin_token')
./src/stores/authStore.js:      tokens['ddadmin'] = {
./src/stores/authStore.js:        token: ddadminTokenVal,
./src/stores/authStore.js:    return tokens
./src/stores/authStore.js:    if (primaryToken.value || localStorage.getItem('token')) {
./src/stores/authStore.js:    if (ddadminToken.value || localStorage.getItem('ddadmin_token')) {
./src/stores/authStore.js:      token: ddadminToken.value,
./src/stores/authStore.js:      token: myToken.value,
./src/stores/authStore.js:      token: primaryToken.value,
./src/main.js:import Password from 'primevue/password'
./src/components/integram-landing/IntegramFooter.vue:              :key="index"
./src/components/integram-landing/IntegramHero.vue:@keyframes fadeInScale {
./src/components/integram-landing/IntegramFeatures.vue:            :key="index"
./src/components/integram-landing/IntegramFeatures.vue:        :key="index"
./src/components/integram/IntegramInfo.vue:          <div v-for="(lesson, index) in lessons" :key="index" class="col-12 md:col-6 lg:col-4 mb-3">
./src/components/integram/IntegramReportViewer.vue:              :key="`header-${index}`"
./src/components/integram/IntegramReportViewer.vue:              :key="`filter-${index}`"
./src/components/integram/IntegramReportViewer.vue:            :key="`row-${rowIndex}`"
./src/components/integram/IntegramReportViewer.vue:              :key="`cell-${rowIndex}-${colIndex}`"
./src/components/integram/IntegramReportViewer.vue:              :key="`total-${index}`"
./src/components/integram/QuickEditModal.vue:        <div v-for="req in requisites" :key="req.id" class="field">
./src/components/integram/MentionAutocomplete.vue:      @keydown="handleKeydown"
./src/components/integram/MentionAutocomplete.vue:        :key="user.id"
./src/components/integram/MentionAutocomplete.vue: * Handle keyboard navigation
./src/components/integram/MentionAutocomplete.vue:  switch (event.key) {
./src/components/integram/MentionDisplay.vue:    <template v-for="(segment, index) in segments" :key="index">
./src/components/integram/IntegramUpload.vue:                :key="col.field"
./src/components/integram/IntegramUpload.vue:                <Badge v-if="Object.keys(columnFormulas).length > 0" :value="Object.keys(columnFormulas).length" severity="success" />
./src/components/integram/IntegramUpload.vue:                  @keyup.enter="saveFormula"
./src/components/integram/IntegramUpload.vue:                      :key="col.field"
./src/components/integram/IntegramUpload.vue:                :key="index"
./src/components/integram/IntegramUpload.vue:      settingsOptions.value = Object.keys(parsed).map(key => ({
./src/components/integram/IntegramUpload.vue:        label: key,
./src/components/integram/IntegramUpload.vue:        value: key
./src/components/integram/DataTable/dialogs/MemoEditDialog.vue:        @keydown.enter.stop
./src/components/integram/DataTable/dialogs/MemoEditDialog.vue:        @keydown.ctrl.enter="$emit('save')"
./src/components/integram/DataTable/dialogs/MemoEditDialog.vue:        @keydown.meta.enter="$emit('save')"
./src/components/integram/DataTable/dialogs/ConditionalFormattingDialog.vue:            :key="color"
./src/components/integram/DataTable/dialogs/ConditionalFormattingDialog.vue:            :key="color"
./src/components/integram/DataTable/dialogs/ConditionalFormattingDialog.vue:          :key="existingRule.id"
./src/components/integram/DataTable/dialogs/ButtonActionDialog.vue:          :key="action.id"
./src/components/integram/DataTable/dialogs/ButtonActionDialog.vue:          :key="paramName"
./src/components/integram/DataTable/composables/useCellEditing.js:  // Capture phase handler for ESC key in dropdowns
./src/components/integram/DataTable/composables/useCellEditing.js:    if (event.key === 'Escape' && isDropdownOpen.value) {
./src/components/integram/DataTable/composables/useCellEditing.js:      document.addEventListener('keydown', handleGlobalEscForDropdown, true) // true = capture phase
./src/components/integram/DataTable/composables/useCellEditing.js:      document.removeEventListener('keydown', handleGlobalEscForDropdown, true)
./src/components/integram/DataTable/composables/useCellEditing.js:    console.log('[handleCellDoubleClick] Cell keys:', Object.keys(cell || {}))
./src/components/integram/DataTable/composables/useCellEditing.js:    // Only auto-save if user is not cancelling (ESC key)
./src/components/integram/DataTable/composables/useCellEditing.js:    if (event.key === 'Escape') {
./src/components/integram/DataTable/composables/useCellEditing.js:    } else if (event.key === 'a' && (event.ctrlKey || event.metaKey)) {
./src/components/integram/DataTable/composables/useCellEditing.js:    } else if (event.key === 'Enter' && !event.shiftKey) {
./src/components/integram/DataTable/composables/useCellEditing.js:    if (event.key === 'Escape') {
./src/components/integram/DataTable/composables/useCellEditing.js:    } else if (event.key === 'Enter') {
./src/components/integram/DataTable/composables/useCellEditing.js:    // Only auto-save if user is not cancelling (ESC key)
./src/components/integram/DataTable/composables/useCellEditing.js:    document.removeEventListener('keydown', handleGlobalEscForDropdown, true)
./src/components/integram/DataTable/composables/useDirectoryCache.js:    const dirTableIds = Object.keys(directoryCache.value)
./src/components/integram/DataTable/composables/useGrouping.js:      result.push({ type: 'group', key: groupKey, data: group })
./src/components/integram/DataTable/composables/useGrouping.js:    expandedGroups.value = Object.keys(groups).reduce((acc, key) => {
./src/components/integram/DataTable/composables/useGrouping.js:      acc[key] = true
./src/components/integram/DataTable/composables/useGrouping.js:    expandedGroups.value = Object.keys(groups).reduce((acc, key) => {
./src/components/integram/DataTable/composables/useGrouping.js:      acc[key] = true
./src/components/integram/DataTable/composables/useUserMentions.js:          responseKeys: Object.keys(response)
./src/components/integram/DataTable/composables/useDirectoryPreload.js:  // Generate cache key for directory row
./src/components/integram/DataTable/composables/useDirectoryPreload.js:  // Handle row focus (keyboard navigation)
./src/components/integram/DataTable/composables/useDirectoryPreload.js:    // Only preload if focus came from keyboard navigation (tab)
./src/components/integram/IntegramTableView.vue:              <div v-for="req in requisites" :key="req.id" class="col-12 md:col-3">
./src/components/integram/IntegramTableView.vue:                      @keydown.enter="saveEdit(slotProps.data)"
./src/components/integram/IntegramTableView.vue:                      @keydown.esc="cancelEdit"
./src/components/integram/IntegramTableView.vue:              :key="req.id"
./src/components/integram/IntegramTableView.vue:                      @keydown.enter="saveEdit(slotProps.data, req.id)"
./src/components/integram/IntegramTableView.vue:                      @keydown.esc="cancelEdit"
./src/components/integram/IntegramTableView.vue:                      @keydown.enter="saveEdit(slotProps.data, req.id)"
./src/components/integram/IntegramTableView.vue:                      @keydown.esc="cancelEdit"
./src/components/integram/IntegramTableView.vue:                      @keydown.enter="saveEdit(slotProps.data, req.id)"
./src/components/integram/IntegramTableView.vue:                      @keydown.esc="cancelEdit"
./src/components/integram/IntegramTableView.vue:                      @keydown.esc="cancelEdit"
./src/components/integram/IntegramTableView.vue:                      @keydown.enter="saveEdit(slotProps.data, req.id)"
./src/components/integram/IntegramTableView.vue:                      @keydown.esc="cancelEdit"
./src/components/integram/IntegramTableView.vue:                :key="req.id"
./src/components/integram/IntegramTableView.vue:        <div v-for="req in requisites" :key="req.id" class="field">
./src/components/integram/IntegramTableView.vue:    for (const key in filters.value) {
./src/components/integram/IntegramTableView.vue:      if (key.startsWith('req_') && filters.value[key]) {
./src/components/integram/IntegramTableView.vue:        const reqId = key.replace('req_', '');
./src/components/integram/IntegramTableView.vue:        if (!value || !value.toLowerCase().includes(filters.value[key].toLowerCase())) {
./src/components/integram/IntegramTableView.vue:  if (event.key === 'Escape' && inlineEditEnabled.value) {
./src/components/integram/IntegramTableView.vue:    // Build requisites object (key = reqId, value = formatted value)
./src/components/integram/IntegramTableView.vue:    if (Object.keys(createForm.value.requisites).length > 0) {
./src/components/integram/IntegramTableView.vue:      Object.keys(createForm.value.requisites).forEach(reqId => {
./src/components/integram/IntegramTableView.vue:  document.addEventListener('keydown', handleGlobalKeydown);
./src/components/integram/IntegramTableView.vue:  document.removeEventListener('keydown', handleGlobalKeydown);
./src/components/integram/IntegramSQL.vue:              :key="index"
./src/components/integram/IntegramSQL.vue:              :key="col.field"
./src/components/integram/IntegramSQL.vue:              :key="index"
./src/components/integram/IntegramSQL.vue:      resultColumns.value = Object.keys(results.value[0]).map(key => ({
./src/components/integram/IntegramSQL.vue:        field: key,
./src/components/integram/IntegramSQL.vue:        header: key
./src/components/integram/IntegramForm.vue:              :key="index"
./src/components/integram/IntegramForm.vue:                      :key="col.field"
./src/components/integram/IntegramEnhancedObjectEditor.vue:          <TabPanel v-for="tab in tabs" :key="tab.id" :header="tab.name">
./src/components/integram/IntegramEnhancedObjectEditor.vue:                :key="req.id"
./src/components/integram/IntegramEnhancedObjectEditor.vue:            :key="req.id"
./src/components/integram/IntegramEnhancedObjectEditor.vue:            :key="btn.id"
./src/components/integram/IntegramEnhancedObjectEditor.vue:    if (authInfo && authInfo.token) {
./src/components/integram/IntegramEnhancedObjectEditor.vue:        token: authInfo.token,
./src/components/integram/IntegramEnhancedObjectEditor.vue:        // Type with req.ref = REFERENCE (foreign key to another table)
./src/components/integram/IntegramEnhancedObjectEditor.vue:  const password = formData.value.t20 || ''
./src/components/integram/IntegramEnhancedObjectEditor.vue:  const invite = `–°—Å—ã–ª–∫–∞ –¥–ª—è –≤—Ö–æ–¥–∞: https://${window.location.host}/${props.database}?u=${username}\n–ø–∞—Ä–æ–ª—å: ${password}`
./src/components/integram/IntegramTypeEditor.vue:              @keyup="filterExistingTypes"
./src/components/integram/IntegramTypeEditor.vue:        <div v-for="type in filteredTypes" :key="type.id" class="type-card mb-3" :data-type-id="type.id">
./src/components/integram/IntegramTypeEditor.vue:                    :key="req.id"
./src/components/integram/IntegramTypeEditor.vue:            @keyup.enter="createSubordinateType"
./src/components/integram/IntegramTypeEditor.vue:            @keyup.enter="saveEditedType"
./src/components/integram/IntegramTypeEditor.vue:const baseTypeIds = new Set(Object.keys(baseTypeNameMap));
./src/components/integram/IntegramTypeEditor.vue:      // DEBUG: Log all available keys in editTypes to understand API structure
./src/components/integram/IntegramTypeEditor.vue:      console.log('[IntegramTypeEditor] DEBUG: editTypes keys:', Object.keys(editTypes));
./src/components/integram/IntegramTypeEditor.vue:      const sampleKeys = Object.keys(editTypes).slice(0, 10);
./src/components/integram/IntegramTypeEditor.vue:      sampleKeys.forEach(key => {
./src/components/integram/IntegramTypeEditor.vue:        const arr = editTypes[key];
./src/components/integram/IntegramTypeEditor.vue:          console.log(`  ${key}: [${arr.slice(0, 5).join(', ')}] (${arr.length} items)`);
./src/components/integram/IntegramDictionary.vue:          :key="category.id || category.name"
./src/components/integram/IntegramDictionary.vue:              :key="type.id"
./src/components/integram/IntegramDictionary.vue: * Transliterate between Russian and English keyboard layouts
./src/components/integram/IntegramDictionary.vue:  // Search now supports RU/EN keyboard layout switching via isSubstring
./src/components/integram/IntegramObjectEditor.vue:                @keyup.enter="loadObject"
./src/components/integram/IntegramObjectEditor.vue:            :key="req.id"
./src/components/integram/IntegramObjectEditor.vue:              :key="table.typeId"
./src/components/integram/IntegramObjectEditor.vue:    Object.keys(editedValues).forEach(reqId => {
./src/components/integram/IntegramObjectEditor.vue:        Object.keys(editedValues).forEach(reqId => {
./src/components/integram/IntegramObjectEditor.vue:  Object.keys(editedValues).forEach(key => delete editedValues[key])
./src/components/integram/IntegramSchemaTree.vue:        key: `req-${req.id}`,
./src/components/integram/IntegramSchemaTree.vue:      key: `type-${type.id}`,
./src/components/integram/IntegramSchemaTree.vue:  const keys = {}
./src/components/integram/IntegramSchemaTree.vue:      keys[node.key] = true
./src/components/integram/IntegramSchemaTree.vue:  expandedKeys.value = keys
./src/components/integram/IntegramSchemaTree.vue:  const key = `type-${typeId}`
./src/components/integram/IntegramSchemaTree.vue:  expandedKeys.value = { ...expandedKeys.value, [key]: true }
./src/components/integram/IntegramSchemaTree.vue:  selectedKey.value = { [key]: true }
./src/components/integram/IntegramSchemaTree.vue:  if (props.typesData.length > 0 && Object.keys(expandedKeys.value).length === 0) {
./src/components/integram/IntegramSchemaTree.vue:    const keys = {}
./src/components/integram/IntegramSchemaTree.vue:      keys[node.key] = true
./src/components/integram/IntegramSchemaTree.vue:    expandedKeys.value = keys
./src/components/integram/IntegramQuiz.vue:                  :key="index"
./src/components/integram/IntegramQuiz.vue:                  :key="index"
./src/components/integram/IntegramQuiz.vue:              :key="index"
./src/components/integram/QueryBuilderGUI.vue:        :key="control.id"
./src/components/integram/IntegramObjectList.vue:                :key="opt.mode"
./src/components/integram/IntegramObjectList.vue:                  @keyup.enter="applyFilters"
./src/components/integram/IntegramObjectList.vue:                  @keyup.enter="applyFilters"
./src/components/integram/IntegramObjectList.vue:              :key="field.id"
./src/components/integram/IntegramObjectList.vue:                  @keyup.enter="applyFilters"
./src/components/integram/IntegramObjectList.vue:                  @keydown.enter="saveInlineEdit"
./src/components/integram/IntegramObjectList.vue:                  @keydown.escape="cancelInlineEdit"
./src/components/integram/IntegramObjectList.vue:            :key="col.field"
./src/components/integram/IntegramObjectList.vue:                  @keydown.enter="saveInlineEdit"
./src/components/integram/IntegramObjectList.vue:                  @keydown.escape="cancelInlineEdit"
./src/components/integram/IntegramObjectList.vue:            :key="`arr_${arrCol.id}`"
./src/components/integram/IntegramObjectList.vue:        <div v-for="field in requiredFields" :key="field.id" class="field">
./src/components/integram/IntegramObjectList.vue:            <li v-for="(value, key) in filters.fields" :key="key">
./src/components/integram/IntegramObjectList.vue:              –ü–æ–ª–µ {{ key }}: "{{ value }}"
./src/components/integram/IntegramObjectList.vue:            <li v-if="!filters.search && !filters.parentId && Object.keys(filters.fields || {}).length === 0">
./src/components/integram/IntegramObjectList.vue:    const headers = Object.keys(exportData[0])
./src/components/integram/IntegramObjectList.vue:      const headers = Object.keys(exportData[0] || {})
./src/components/integram/IntegramObjectList.vue:  if (event.key === 'Escape' && selectedObjects.value.length > 0) {
./src/components/integram/IntegramObjectList.vue:  if (event.shiftKey && event.key === 'Delete' && selectedObjects.value.length > 0) {
./src/components/integram/IntegramObjectList.vue:  if ((event.ctrlKey || event.metaKey) && event.key === 'e' && selectedObjects.value.length > 0) {
./src/components/integram/IntegramObjectList.vue:  if ((event.ctrlKey || event.metaKey) && event.key === 'n') {
./src/components/integram/IntegramObjectList.vue:  if ((event.ctrlKey || event.metaKey) && event.key === 'r') {
./src/components/integram/IntegramObjectList.vue:  // Add keyboard shortcuts
./src/components/integram/IntegramObjectList.vue:  window.addEventListener('keydown', handleKeyboardShortcuts)
./src/components/integram/IntegramObjectList.vue:  // Remove keyboard shortcuts
./src/components/integram/IntegramObjectList.vue:  window.removeEventListener('keydown', handleKeyboardShortcuts)
./src/components/integram/IntegramObjectList.vue:@keyframes slideUp {
./src/components/integram/fields/PasswordField.vue:  <div class="password-field">
./src/components/integram/fields/ReferenceField.vue:        :key="item.msId || item.id"
./src/components/integram/fields/ReferenceField.vue:        :key="option.id"
./src/components/integram/fields/ReferenceField.vue:          @keyup.enter="createNewReference"
./src/components/integram/IntegramReport.vue:          :key="index"
./src/components/integram/IntegramReport.vue:        :key="index"
./src/components/integram/IntegramReport.vue:          <span v-for="(total, index) in totals" :key="index" class="mr-4">
./src/components/integram/IntegramFormBuilder.vue:              :key="panel.id"
./src/components/integram/IntegramFormBuilder.vue:              :key="field"
./src/components/integram/IntegramFormBuilder.vue:                  <RadioButton v-model="pivotData.rowOrder" inputId="rowAsc" value="key_a_to_z" />
./src/components/integram/IntegramFormBuilder.vue:                  <RadioButton v-model="pivotData.rowOrder" inputId="rowDesc" value="key_z_to_a" />
./src/components/integram/IntegramFormBuilder.vue:                  <RadioButton v-model="pivotData.colOrder" inputId="colAsc" value="key_a_to_z" />
./src/components/integram/IntegramFormBuilder.vue:                  <RadioButton v-model="pivotData.colOrder" inputId="colDesc" value="key_z_to_a" />
./src/components/integram/IntegramFormBuilder.vue:  rowOrder: 'key_a_to_z',
./src/components/integram/IntegramFormBuilder.vue:  colOrder: 'key_a_to_z',
./src/components/integram/IntegramFormBuilder.vue:      rowOrder: panel.pivotConfig.rowOrder || 'key_a_to_z',
./src/components/integram/IntegramFormBuilder.vue:      colOrder: panel.pivotConfig.colOrder || 'key_a_to_z',
./src/components/integram/IntegramFormBuilder.vue:      rowOrder: 'key_a_to_z',
./src/components/integram/IntegramFormBuilder.vue:      colOrder: 'key_a_to_z',
./src/components/integram/IntegramFormBuilder.vue:      const reportKey = Object.keys(reportData).find(key => key.startsWith('&rep.'))
./src/components/integram/IntegramFormBuilder.vue:        const keys = Object.keys(reportData).filter(k => !k.startsWith('&'))
./src/components/integram/IntegramFormBuilder.vue:        if (keys.length > 0) {
./src/components/integram/IntegramFormBuilder.vue:          pivotAvailableFields.value = keys
./src/components/integram/IntegramFormBuilder.vue::deep(.p-chips-token) {
./src/components/integram/IntegramObjectTable.vue:        :key="reqId"
./src/components/integram/IntegramReportEmbed.vue:          columns = Object.keys(response[0])
./src/components/integram/DataTable.vue:          <template v-for="(item, idx) in currentDirRow.rows[0].items.slice(0, 10)" :key="idx">
./src/components/integram/DataTable.vue:            :key="idx"
./src/components/integram/DataTable.vue:      :key="'filter-' + header.id"
./src/components/integram/DataTable.vue:            :key="value"
./src/components/integram/DataTable.vue:        <div v-for="header in editingRow?.headers" :key="header.headerId" class="form-field" :class="{'has-expanding-content': isExpandingField(header.type)}" @dblclick.stop="handleCellDoubleClick(header, row.cells[header.id])">
./src/components/integram/DataTable.vue:        <div v-for="type in filteredTypes" :key="type.value" class="type-item" @click="changeColumnType(type.value)" :class="{ 'active-type': currentHeader?.type === type.value }">
./src/components/integram/DataTable.vue:  :key="header.id"
./src/components/integram/DataTable.vue:        @keydown.enter="saveHeaderRename"
./src/components/integram/DataTable.vue:        @keydown.esc="cancelHeaderRename"
./src/components/integram/DataTable.vue:          <template v-for="(item, itemIndex) in visibleRows" :key="item.type === 'group' ? `group-${item.key}` : item.data.id">
./src/components/integram/DataTable.vue:            <tr v-if="item.type === 'group'" class="group-header" @click="toggleGroup(item.key)">
./src/components/integram/DataTable.vue:                <i :class="['pi', expandedGroups[item.key] ? 'pi-chevron-down' : 'pi-chevron-right']"></i>
./src/components/integram/DataTable.vue:                {{ formatMultiGroupHeader(item.key) }} ({{ item.data.rows.length }})
./src/components/integram/DataTable.vue:                :key="header.id"
./src/components/integram/DataTable.vue:                        <span v-for="(dirValue, idx) in item.data.cells[header.id].dirValues" :key="idx" class="dir-tag" @click.stop="openDirectory(header, dirValue.dirRowId)" @mouseenter="showDirInfo($event, header, dirValue.dirRowId)" @mouseleave="hideDirInfo">
./src/components/integram/DataTable.vue:                      @keydown="handleMultiSelectKeydown"
./src/components/integram/DataTable.vue:                    <Dropdown v-else-if="currentEditingHeader?.dirTableId" v-model="editingValue" :options="editingOptions" optionLabel="value" optionValue="id" :filter="true" :showClear="true" :loading="isLoadingDirectory" :disabled="isLoadingDirectory" :placeholder="isLoadingDirectory ? '–ó–∞–≥—Ä—É–∑–∫–∞...' : '–í—ã–±–µ—Ä–∏—Ç–µ...'" class="cell-editor seamless-editor" @keydown="handleDropdownKeydown" @show="isDropdownOpen = true" @hide="handleDropDownHide" @click="handleDropdownClick" />
./src/components/integram/DataTable.vue:                      @keydown="handleDropdownKeydown"
./src/components/integram/DataTable.vue:                      @keydown.enter="saveAndCloseCellEdit(header.id, item.data.id)"
./src/components/integram/DataTable.vue:                      @keydown.esc="cancelCellEdit"
./src/components/integram/DataTable.vue:                    <component v-else :is="getEditorComponent(header.type)" ref="cellEditorInput" v-model="editingValue" @keydown.enter="saveAndCloseCellEdit(header.id, item.data.id)" @keydown.esc="cancelCellEdit" @blur="saveAndCloseCellEdit(header.id, item.data.id)" :binary="header.type === 11" :showIcon="true" :dateFormat="header.type === 9 ? 'dd.mm.yy' : 'dd.mm.yy HH:mm'" :showTime="header.type === 4" :showSeconds="header.type === 4" class="cell-editor seamless-editor" v-bind="getEditorProps(header.type, header.dirTableId, getDirectoryOptions(header.dirTableId), props.database)" />
./src/components/integram/DataTable.vue:              :key="`footer-${header.id}`"
./src/components/integram/DataTable.vue:  typeId: { type: [Number, String], default: null }, // Table type ID for localStorage keys
./src/components/integram/DataTable.vue:// const _focusedCell = ref(null) // { headerId, rowId } for keyboard navigation - reserved for future use
./src/components/integram/DataTable.vue:// localStorage key for row heights
./src/components/integram/DataTable.vue:  const key = getRowHeightsStorageKey()
./src/components/integram/DataTable.vue:  if (!key) return {}
./src/components/integram/DataTable.vue:    const stored = localStorage.getItem(key)
./src/components/integram/DataTable.vue:  const key = getRowHeightsStorageKey()
./src/components/integram/DataTable.vue:  if (!key) return
./src/components/integram/DataTable.vue:    localStorage.setItem(key, JSON.stringify(rowHeights.value))
./src/components/integram/DataTable.vue:// before our Vue @keydown handler can set the isCancellingEdit flag
./src/components/integram/DataTable.vue://   if (event.key === 'Escape' && isDropdownOpen.value) {
./src/components/integram/DataTable.vue://     document.addEventListener('keydown', handleGlobalEscForDropdown, true) // true = capture phase
./src/components/integram/DataTable.vue://     document.removeEventListener('keydown', handleGlobalEscForDropdown, true)
./src/components/integram/DataTable.vue:  if ((event.ctrlKey || event.metaKey) && event.key === 'z' && !event.shiftKey) {
./src/components/integram/DataTable.vue:      (event.key === 'y' || (event.key === 'z' && event.shiftKey))) {
./src/components/integram/DataTable.vue://     result.push({ type: 'group', key: groupKey, data: group })
./src/components/integram/DataTable.vue:      const [key, value] = segment.split('=')
./src/components/integram/DataTable.vue:      if (key === 'ALIAS' && value) {
./src/components/integram/DataTable.vue:      } else if (key && value) {
./src/components/integram/DataTable.vue:        params[key] = value
./src/components/integram/DataTable.vue:      // First non-key-value segment is the endpoint
./src/components/integram/DataTable.vue:    for (const [key, value] of Object.entries(params)) {
./src/components/integram/DataTable.vue:        attrsStr += `:${key}=${value}`
./src/components/integram/DataTable.vue:      const [key, value] = segment.split('=')
./src/components/integram/DataTable.vue:      if (key !== 'ALIAS' && key && value) {
./src/components/integram/DataTable.vue:        params[key] = value
./src/components/integram/DataTable.vue:  for (const [key, value] of Object.entries(params)) {
./src/components/integram/DataTable.vue:    substitutedParams[key] = String(value)
./src/components/integram/DataTable.vue:    for (const cacheKey of formulaCache.value.keys()) {
./src/components/integram/DataTable.vue:    for (const rangeKey of rangeCacheMap.value.keys()) {
./src/components/integram/DataTable.vue:      return `<span class="cell-chip cell-password" title="–ü–∞—Ä–æ–ª—å —Å–∫—Ä—ã—Ç"><i class="pi pi-lock"></i><span>******</span></span>`
./src/components/integram/DataTable.vue:          const [key, value] = segment.split('=')
./src/components/integram/DataTable.vue:          if (key === 'ALIAS' && value) {
./src/components/integram/DataTable.vue:          // First non-key-value segment is the endpoint
./src/components/integram/DataTable.vue://   expandedGroups.value = Object.keys(groups).reduce((acc, key) => {
./src/components/integram/DataTable.vue://     acc[key] = true
./src/components/integram/DataTable.vue://   expandedGroups.value = Object.keys(groups).reduce((acc, key) => {
./src/components/integram/DataTable.vue://     acc[key] = true
./src/components/integram/DataTable.vue:  if ((event.ctrlKey || event.metaKey) && event.key === 'c') {
./src/components/integram/DataTable.vue:  if ((event.ctrlKey || event.metaKey) && event.key === 'v') {
./src/components/integram/DataTable.vue:  switch (event.key) {
./src/components/integram/DataTable.vue:      // Enter key - start editing selected cell
./src/components/integram/DataTable.vue:  // Only auto-save if user is not cancelling (ESC key)
./src/components/integram/DataTable.vue://   if (event.key === 'Escape') {
./src/components/integram/DataTable.vue://   } else if (event.key === 'a' && (event.ctrlKey || event.metaKey)) {
./src/components/integram/DataTable.vue://   } else if (event.key === 'Enter' && !event.shiftKey) {
./src/components/integram/DataTable.vue:// Issue #5005: Handle dropdown keydown - backup handler (main ESC handling via capture phase listener)
./src/components/integram/DataTable.vue://   if (event.key === 'Escape') {
./src/components/integram/DataTable.vue://   } else if (event.key === 'Enter') {
./src/components/integram/DataTable.vue:  // Only auto-save if user is not cancelling (ESC key)
./src/components/integram/DataTable.vue:// Get cache key for directory row
./src/components/integram/DataTable.vue:// Handle row focus (keyboard navigation)
./src/components/integram/DataTable.vue:  // Only preload if focus came from keyboard navigation (tab)
./src/components/integram/DataTable.vue://   const dirTableIds = Object.keys(directoryCache.value)
./src/components/integram/DataTable.vue:  document.removeEventListener('keydown', handleKeyboardNavigation)
./src/components/integram/DataTable.vue:  document.addEventListener('keydown', handleKeyboardNavigation)
./src/components/integram/DataTable.vue:  document.removeEventListener('keydown', handleGlobalEscForDropdown, true)
./src/components/integram/DataTable.vue:@keyframes editing-pulse {
./src/components/integram/DataTable.vue:/* Chips/tokens must be visible with colors by index */
./src/components/integram/DataTable.vue:.seamless-editor :deep(.p-multiselect-token),
./src/components/integram/DataTable.vue:.seamless-editor :deep(.p-multiselect-token:hover),
./src/components/integram/DataTable.vue:.seamless-editor :deep(.p-multiselect-token:nth-child(8n+1)) { background: var(--p-blue-100, #dbeafe) !important; color: var(--p-blue-700, #1d4ed8) !important; }
./src/components/integram/DataTable.vue:.seamless-editor :deep(.p-multiselect-token:nth-child(8n+2)) { background: var(--p-green-100, #dcfce7) !important; color: var(--p-green-700, #15803d) !important; }
./src/components/integram/DataTable.vue:.seamless-editor :deep(.p-multiselect-token:nth-child(8n+3)) { background: var(--p-amber-100, #fef3c7) !important; color: var(--p-amber-700, #b45309) !important; }
./src/components/integram/DataTable.vue:.seamless-editor :deep(.p-multiselect-token:nth-child(8n+4)) { background: var(--p-purple-100, #f3e8ff) !important; color: var(--p-purple-700, #7e22ce) !important; }
./src/components/integram/DataTable.vue:.seamless-editor :deep(.p-multiselect-token:nth-child(8n+5)) { background: var(--p-pink-100, #fce7f3) !important; color: var(--p-pink-700, #be185d) !important; }
./src/components/integram/DataTable.vue:.seamless-editor :deep(.p-multiselect-token:nth-child(8n+6)) { background: var(--p-cyan-100, #cffafe) !important; color: var(--p-cyan-700, #0e7490) !important; }
./src/components/integram/DataTable.vue:.seamless-editor :deep(.p-multiselect-token:nth-child(8n+7)) { background: var(--p-orange-100, #ffedd5) !important; color: var(--p-orange-700, #c2410c) !important; }
./src/components/integram/DataTable.vue:.seamless-editor :deep(.p-multiselect-token:nth-child(8n+8)) { background: var(--p-teal-100, #ccfbf1) !important; color: var(--p-teal-700, #0f766e) !important; }
./src/components/integram/DataTable.vue:.seamless-editor :deep(.p-multiselect-token-icon),
./src/components/integram/DataTable.vue::deep(.cell-password) {
./src/components/integram/DataTable.vue::deep(.cell-password:hover) {
./src/components/integram/DataTable.vue:/* Date badge styles - consistent with multiselect tokens */
./src/components/integram/IntegramSchemaLegacy.vue:      <g v-for="line in visibleLines" :key="line.id" class="connection-group">
./src/components/integram/IntegramSchemaLegacy.vue:        :key="type.id"
./src/components/integram/IntegramSchemaLegacy.vue:            :key="req.id"
./src/components/integram/IntegramSchemaLegacy.vue:            :key="req.id"
./src/components/integram/IntegramSchemaLegacy.vue:@keyframes fadeInConnection {
./src/components/integram/IntegramSchemaLegacy.vue:@keyframes drawPath {
./src/components/integram/IntegramSchemaLegacy.vue:@keyframes pulseCircle {
./src/components/integram/IntegramQueryBuilder.vue:                :key="index"
./src/components/integram/IntegramQueryBuilder.vue:                :key="'agg-' + index"
./src/components/integram/IntegramQueryBuilder.vue:                :key="index"
./src/components/integram/IntegramQueryBuilder.vue:                :key="index"
./src/components/integram/IntegramQueryBuilder.vue:                :key="'having-' + index"
./src/components/integram/IntegramQueryBuilder.vue:                :key="'set-' + index"
./src/components/integram/IntegramQueryBuilder.vue:                :key="index"
./src/components/integram/IntegramQueryBuilder.vue:              :key="col.field"
./src/components/integram/IntegramQueryBuilder.vue:      const columns = response.columns || Object.keys(response.data[0] || {})
./src/components/integram/IntegramDataTableWrapper.vue:            @keydown.enter="handleCreate"
./src/components/integram/IntegramDataTableWrapper.vue:        <div v-for="req in editableRequisites" :key="req.id" class="field">
./src/components/integram/IntegramDataTableWrapper.vue:            @keydown.enter="createColumn"
./src/components/integram/IntegramDataTableWrapper.vue:        <div v-for="column in columnOptions" :key="column.id" class="flex align-items-center p-2 surface-hover border-round">
./src/components/integram/IntegramDataTableWrapper.vue:          :key="index"
./src/components/integram/IntegramDataTableWrapper.vue:          :key="nestedDialog.tableId + '-' + nestedDialog.parentRowId"
./src/components/integram/IntegramDataTableWrapper.vue:          :key="'dir-' + directoryDialog.typeId + '-' + directoryDialog.dirRowId"
./src/components/integram/IntegramDataTableWrapper.vue:            <i class="pi pi-key"></i>
./src/components/integram/IntegramDataTableWrapper.vue:    if (Object.keys(serverFilters).length > 0) {
./src/components/integram/IntegramDataTableWrapper.vue:    console.log('[loadData] API response reqs sample:', data.reqs ? Object.keys(data.reqs)[0] : 'none', data.reqs ? data.reqs[Object.keys(data.reqs)[0]] : null)
./src/components/integram/IntegramDataTableWrapper.vue:    console.log(`[buildServerFilters] Filter key: ${filterKey} for termId: ${header.termId} (typeId: ${typeId.value})`)
./src/components/integram/IntegramDataTableWrapper.vue:  // Debug: check if ref_XXX keys exist in reqs
./src/components/integram/IntegramDataTableWrapper.vue:    console.log('[parseRows] First object reqs keys:', firstObjReqs ? Object.keys(firstObjReqs) : 'none')
./src/components/integram/IntegramDataTableWrapper.vue:    console.log('[parseRows] Sample ref keys:', firstObjReqs ? Object.keys(firstObjReqs).filter(k => k.startsWith('ref_')) : 'none')
./src/components/integram/IntegramDataTableWrapper.vue:  if (event.key === 'F3') {
./src/components/integram/IntegramDataTableWrapper.vue:        Object.keys(arrType).forEach(reqId => {
./src/components/integram/IntegramDataTableWrapper.vue:    // Force re-render of nested table by changing key
./src/components/integram/IntegramDataTableWrapper.vue:      for (const [key, value] of Object.entries(params)) {
./src/components/integram/IntegramDataTableWrapper.vue:          newAttrs += `:${key}=${value}`
./src/components/integram/IntegramDataTableWrapper.vue:      if (params && Object.keys(params).length > 0) {
./src/components/integram/IntegramDataTableWrapper.vue:        for (const [key, value] of Object.entries(params)) {
./src/components/integram/IntegramDataTableWrapper.vue:            formData.append(key, value)
./src/components/integram/IntegramDataTableWrapper.vue:    // termId is the requisite ID used in _m_save/{objectId} with key t{termId}
./src/components/integram/IntegramDataTableWrapper.vue:// Issue #5005: ESC key handler for canceling cell edit
./src/components/integram/IntegramDataTableWrapper.vue:  if (event.key === 'Escape') {
./src/components/integram/IntegramDataTableWrapper.vue:  document.addEventListener('keydown', handleGlobalEsc)
./src/components/integram/IntegramDataTableWrapper.vue:  document.addEventListener('keydown', handleSearchNavigation)
./src/components/integram/IntegramDataTableWrapper.vue:  document.removeEventListener('keydown', handleGlobalEsc)
./src/components/integram/IntegramDataTableWrapper.vue:  document.removeEventListener('keydown', handleSearchNavigation)
./src/components/onboarding/OnboardingWizard.vue:        :key="n"
./src/components/onboarding/OnboardingWizard.vue:      <Card class="token-gift-card mb-4">
./src/components/onboarding/OnboardingWizard.vue:              <ul class="token-usage-list">
./src/components/onboarding/OnboardingWizard.vue:          :key="feature.id"
./src/components/onboarding/OnboardingWizard.vue:          :key="solution.id"
./src/components/onboarding/OnboardingWizard.vue:          :key="agent.id"
./src/components/onboarding/OnboardingWizard.vue:                      :key="feature"
./src/components/onboarding/OnboardingWizard.vue:@keyframes fadeIn {
./src/components/onboarding/OnboardingWizard.vue:.token-gift-card {
./src/components/onboarding/OnboardingWizard.vue:.token-usage-list {
./src/components/onboarding/OnboardingWizard.vue:.token-usage-list li {
./src/components/onboarding/QuickStartChecklist.vue:          :key="item.id"
./src/components/onboarding/OrganizationOnboarding.vue:          :key="n"
./src/components/onboarding/OrganizationOnboarding.vue:            :key="solution.id"
./src/components/onboarding/OrganizationOnboarding.vue:                  <Tag v-for="tag in solution.tags" :key="tag" :value="tag" severity="info" class="mr-2" />
./src/components/onboarding/OrganizationOnboarding.vue:            :key="source.id"
./src/components/onboarding/ContextualHelp.vue:@keyframes slideIn {
./src/components/onboarding/WelcomeScreen.vue:          :key="n"
./src/components/onboarding/WelcomeScreen.vue:            :key="role.id"
./src/components/onboarding/WelcomeScreen.vue:            :key="useCase.id"
./src/components/layout/AppMenuItem.vue:        const parent = document.querySelector(`[data-key="${props.parentItemKey}"]`);
./src/components/layout/AppMenuItem.vue:    switch (event.key) {
./src/components/layout/AppMenuItem.vue:    // Ignore modifiers and special keys
./src/components/layout/AppMenuItem.vue:    if (event.ctrlKey || event.metaKey || event.altKey || event.key.length > 1) {
./src/components/layout/AppMenuItem.vue:    typeaheadBuffer += event.key.toLowerCase();
./src/components/layout/AppMenuItem.vue:            @keydown.enter="item.items && item.items.length > 0 ? itemClick($event, item) : null"
./src/components/layout/AppMenuItem.vue:            @keydown.space.prevent="item.items && item.items.length > 0 ? itemClick($event, item) : null"
./src/components/layout/AppMenuItem.vue:           @keydown="onKeyDown"
./src/components/layout/AppMenuItem.vue:           @keypress="onKeyPress"
./src/components/layout/AppMenuItem.vue:           :data-key="itemKey"
./src/components/layout/AppMenuItem.vue:        <a v-if="!root && (!item.to || item.items) && item.visible !== false" :href="item.url" @click="itemClick($event, item, index)" @keydown="onKeyDown" @keypress="onKeyPress" :class="item.class" :target="item.target" tabindex="0" :data-key="itemKey" :data-parent="parentItemKey" :aria-label="item.label" v-tooltip.right="collapsed ? item.label : null">
./src/components/layout/AppMenuItem.vue:                @keyup.enter="saveRename"
./src/components/layout/AppMenuItem.vue:                @keyup.esc="cancelRename"
./src/components/layout/AppMenuItem.vue:        <router-link v-if="item.to && !item.items && item.visible !== false" @click="itemClick($event, item, index)" @keydown="onKeyDown" @keypress="onKeyPress" @mouseenter="onLinkHover(item.to)" @mouseleave="onLinkLeave(item.to)" :class="[item.class, { 'active-route': checkActiveRoute(item) }]" tabindex="0" :to="item.to" :data-key="itemKey" :data-parent="parentItemKey" :aria-label="item.label" :aria-current="checkActiveRoute(item) ? 'page' : undefined" v-tooltip.right="collapsed ? item.label : null">
./src/components/layout/AppMenuItem.vue:                @keyup.enter="saveRename"
./src/components/layout/AppMenuItem.vue:                @keyup.esc="cancelRename"
./src/components/layout/AppMenuItem.vue:                    :key="child"
./src/components/layout/AppMenuItem.vue:                    <template v-for="(child, idx) in item.items" :key="idx">
./src/components/layout/AppMenuItem.vue:                                    :key="gidx"
./src/components/layout/AppLayout.vue:// Safe route key to prevent "Cannot read properties of undefined (reading 'fullPath')"
./src/components/layout/AppLayout.vue:    if (e.key === 'chat') {
./src/components/layout/AppLayout.vue:    if (e.key === 'chatWidth') {
./src/components/layout/AppLayout.vue:        <SafeRouterView :key="safeRouteKey" />
./src/components/layout/AppLayout.vue:@keyframes chat-spin {
./src/components/layout/Chat.vue:              <div v-for="(msg, index) in aiChat.messages" :key="index" class="message"
./src/components/layout/Chat.vue:                    <div v-for="(attachment, attIndex) in msg.attachments" :key="attIndex" class="attachment-item">
./src/components/layout/Chat.vue:              <InputText ref="aiMessageInputRef" v-model="aiMessage" placeholder="–ó–∞–¥–∞–π—Ç–µ –≤–æ–ø—Ä–æ—Å –ò–ò..." @keyup.enter="handleSendAiMessage"
./src/components/layout/Chat.vue:                :access-token="userAccessToken"
./src/components/layout/Chat.vue:              <div v-for="(attachment, index) in currentAttachments" :key="index" class="current-attachment">
./src/components/layout/Chat.vue:              <div v-for="(msg, index) in activeChat.messages" :key="index" class="message"
./src/components/layout/Chat.vue:                      <div v-for="(attachment, attIndex) in msg.attachments" :key="attIndex" class="attachment-item">
./src/components/layout/Chat.vue:                @keyup.enter="handleSendMessage" @input="handleTyping"
./src/components/layout/Chat.vue:            : activeChat.messages" :key="index" class="modal-message" :class="{ 'modal-user-message': msg.isUser }">
./src/components/layout/Chat.vue:                  <div v-for="(attachment, attIndex) in msg.attachments" :key="attIndex" class="attachment-item">
./src/components/layout/Chat.vue:              :access-token="userAccessToken"
./src/components/layout/Chat.vue:              :show-token-info="false"
./src/components/layout/Chat.vue:              @keyup.enter="handleSendAiMessage" class="modal-input-field" :disabled="aiLoading" />
./src/components/layout/Chat.vue:              @keyup.enter="handleSendMessage" @input="handleTyping"
./src/components/layout/Chat.vue:          <div v-for="(attachment, index) in currentAttachments" :key="index" class="current-attachment">
./src/components/layout/Chat.vue:                     @keyup.enter="handleIntegrÿßŸÖMCPAuth" />
./src/components/layout/Chat.vue:          <label for="integram-password">–ü–∞—Ä–æ–ª—å</label>
./src/components/layout/Chat.vue:          <Password id="integram-password" v-model="integramAuthForm.password"
./src/components/layout/Chat.vue:                    @keyup.enter="handleIntegrÿßŸÖMCPAuth" />
./src/components/layout/Chat.vue:                :disabled="!integramAuthForm.login || !integramAuthForm.password" />
./src/components/layout/Chat.vue:    key: 'chat',
./src/components/layout/Chat.vue:@keyframes blink {
./src/components/layout/Chat.vue:@keyframes pulse {
./src/components/layout/AppConfigurator.vue:const presetOptions = ref(Object.keys(presets));
./src/components/layout/AppConfigurator.vue:            :key="primaryColor.name"
./src/components/layout/AppConfigurator.vue:            :key="surface.name"
./src/components/layout/AppConfigurator.vue:            :key="preset.name"
./src/components/layout/AppConfigurator.vue:            :key="color.name"
./src/components/layout/Profile.vue:            :key="name"
./src/components/layout/Profile.vue:              <i :class="getIconForField(name)" class="field-key mr-3"></i>
./src/components/layout/Profile.vue:              <span class="field-key">{{ name }}:</span>
./src/components/layout/Profile.vue:              <i class="pi pi-server field-key mr-3"></i>
./src/components/layout/Profile.vue:              <span class="field-key">API:</span>
./src/components/layout/Profile.vue:              <i class="pi pi-database field-key mr-3"></i>
./src/components/layout/Profile.vue:              <span class="field-key">–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö:</span>
./src/components/layout/Profile.vue:  Token: 'pi pi-key',
./src/components/layout/Profile.vue:    const token = localStorage.getItem('token')
./src/components/layout/Profile.vue:    if (!token) {
./src/components/layout/Profile.vue:      'X-Authorization': token
./src/components/layout/Profile.vue:      // Response format: { "_xsrf": "...", "token": "...", "user": "d", "role": "admin", "id": "195006", "msg": "" }
./src/components/layout/Profile.vue:    const token = localStorage.getItem('my_token') || localStorage.getItem('token')
./src/components/layout/Profile.vue:    if (!token || !userId) return
./src/components/layout/Profile.vue:      headers: { 'X-Authorization': token }
./src/components/layout/Profile.vue:  ;['_xsrf', 'token', 'user', 'id', 'db', 'apiBase'].forEach(key =>
./src/components/layout/Profile.vue:    localStorage.removeItem(key),
./src/components/layout/Profile.vue:  ;['my_token', 'my_user', 'my_id', 'my_xsrf'].forEach(key =>
./src/components/layout/Profile.vue:    localStorage.removeItem(key),
./src/components/layout/Profile.vue:  ;['ddadmin_token', 'ddadmin_user', 'ddadmin_id', 'ddadmin_xsrf'].forEach(key =>
./src/components/layout/Profile.vue:    localStorage.removeItem(key),
./src/components/layout/Profile.vue:.field-key {
./src/components/layout/AppSidebar.vue:  if (e.key === '/' && !e.ctrlKey && !e.metaKey && !e.altKey) {
./src/components/layout/AppSidebar.vue:  if (e.key === 'Escape') {
./src/components/layout/AppSidebar.vue:  if (e.key === 'ArrowDown' && searchQuery.value && hasExtraResults.value) {
./src/components/layout/AppSidebar.vue:  document.addEventListener('keydown', handleKeyDown)
./src/components/layout/AppSidebar.vue:  document.removeEventListener('keydown', handleKeyDown)
./src/components/layout/AppSidebar.vue:@keyframes fadeInUp {
./src/components/layout/AppMenu.vue:// Internal debounced search query to prevent lag on every keystroke
./src/components/layout/AppMenu.vue:    // Default to admin access for users with authentication tokens
./src/components/layout/AppMenu.vue:    const token = localStorage.getItem('token')
./src/components/layout/AppMenu.vue:    if (!token) {
./src/components/layout/AppMenu.vue:      logger.warn('No authentication token found')
./src/components/layout/AppMenu.vue:  const token = localStorage.getItem('token') || localStorage.getItem('my_token')
./src/components/layout/AppMenu.vue:  if (!token) {
./src/components/layout/AppMenu.vue:    // Issue #3801: Use 'my' token for API access (works as master token for all databases)
./src/components/layout/AppMenu.vue:    // Priority: my_token > integram_session (if db=my) > legacy token
./src/components/layout/AppMenu.vue:    let token = null
./src/components/layout/AppMenu.vue:    // 1. Try my_token first (specific token for 'my' database)
./src/components/layout/AppMenu.vue:    token = localStorage.getItem('my_token')
./src/components/layout/AppMenu.vue:    if (!token) {
./src/components/layout/AppMenu.vue:          // Use token only if it's from 'my' database (master token)
./src/components/layout/AppMenu.vue:            token = session.token
./src/components/layout/AppMenu.vue:    // 3. Fallback to legacy token
./src/components/layout/AppMenu.vue:    if (!token) {
./src/components/layout/AppMenu.vue:      token = localStorage.getItem('token')
./src/components/layout/AppMenu.vue:    if (!token) {
./src/components/layout/AppMenu.vue:      logger.warn('No token available for app_menu request')
./src/components/layout/AppMenu.vue:      hasToken: !!token
./src/components/layout/AppMenu.vue:    integramApiClient.setCredentials('my', token, xsrf, 'my')
./src/components/layout/AppMenu.vue:      firstItemKeys: Array.isArray(response) && response[0] ? Object.keys(response[0]) : []
./src/components/layout/AppMenu.vue:  const token = localStorage.getItem('token') || localStorage.getItem('my_token')
./src/components/layout/AppMenu.vue:  if (!token) {
./src/components/layout/AppMenu.vue:    // Issue #3801: Use 'my' token for API access (works as master token)
./src/components/layout/AppMenu.vue:    // Priority: my_token > integram_session (if db=my) > legacy token
./src/components/layout/AppMenu.vue:    let token = null
./src/components/layout/AppMenu.vue:    // 1. Try my_token first (specific token for 'my' database)
./src/components/layout/AppMenu.vue:    token = localStorage.getItem('my_token')
./src/components/layout/AppMenu.vue:    if (!token) {
./src/components/layout/AppMenu.vue:            token = session.token
./src/components/layout/AppMenu.vue:    // 3. Fallback to legacy token (assume it's from 'my' database if present)
./src/components/layout/AppMenu.vue:    if (!token) {
./src/components/layout/AppMenu.vue:      token = localStorage.getItem('token')
./src/components/layout/AppMenu.vue:    if (!token || !user) {
./src/components/layout/AppMenu.vue:    // Issue #3793: Use my database token for a2025 access via API kernel
./src/components/layout/AppMenu.vue:    integramApiClient.setCredentials('a2025', token, xsrf, 'my')
./src/components/layout/AppMenu.vue:    logger.debug('Using my token for a2025 database access (will use "my" header)')
./src/components/layout/AppMenu.vue:      responseKeys: response ? Object.keys(response).slice(0, 5) : [],
./src/components/layout/AppMenu.vue:      firstItemKeys: Array.isArray(response) && response[0] ? Object.keys(response[0]) : [],
./src/components/layout/AppMenu.vue:        availableFields: Object.keys(firstRow)
./src/components/layout/AppMenu.vue:        documents: Array.from(documentsMap.keys()).slice(0, 10)
./src/components/layout/AppMenu.vue:  // Handle root section reordering (when both parent keys are null)
./src/components/layout/AppMenu.vue:  // Find the section indices from parent keys
./src/components/layout/AppMenu.vue:  const getNestedItem = (menu, keys) => {
./src/components/layout/AppMenu.vue:    for (const key of keys) {
./src/components/layout/AppMenu.vue:      const index = parseInt(key)
./src/components/layout/AppMenu.vue:      <template v-for="(item, i) in filteredModel" :key="item.label || i">
./src/components/layout/AppTopbar.vue:  if (e.key === 'chat') {
./src/components/layout/AppTopbar.vue:  const token = localStorage.getItem('my_token') || localStorage.getItem('token')
./src/components/layout/AppTopbar.vue:  if (!token || !userId) return
./src/components/layout/AppTopbar.vue:      headers: { 'X-Authorization': token }
./src/components/layout/AppTopbar.vue:    if (e.key === 'currentUserPhoto') {
./src/components/layout/AppTopbar.vue:@keyframes agent-pulse {
./src/components/layout/AppTopbar.vue:@keyframes pulse {
./src/components/ensembles/EnsembleDeploymentDialog.vue:            :key="agent.agentId"
./src/components/ensembles/EnsembleDeploymentDialog.vue:          <li v-for="(feature, index) in ensemble.features" :key="index" class="mb-2">
./src/components/ensembles/EnsembleDeploymentDialog.vue:              :key="step.step"
./src/components/ensembles/EnsembleDeploymentDialog.vue:            :key="index"
./src/components/chat/GeneralChatTab.vue:        <div v-for="(msg, index) in messages" :key="index" class="message"
./src/components/chat/GeneralChatTab.vue:                <div v-for="(attachment, attIndex) in msg.attachments" :key="attIndex" class="attachment-item">
./src/components/chat/GeneralChatTab.vue:          <InputText v-model="inputMessage" placeholder="–ù–∞–ø–∏—à–∏—Ç–µ –≤–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ..." @keyup.enter="sendMessage"
./src/components/chat/GeneralChatTab.vue:@keyframes slideIn {
./src/components/chat/AIChatTab.vue:        <div v-for="(msg, index) in messages" :key="index" class="message"
./src/components/chat/AIChatTab.vue:              <div v-for="(attachment, attIndex) in msg.attachments" :key="attIndex" class="attachment-item">
./src/components/chat/AIChatTab.vue:              :access-token="accessToken"
./src/components/chat/AIChatTab.vue:              :show-token-info="false"
./src/components/chat/AIChatTab.vue:          <InputText v-model="inputMessage" placeholder="–ó–∞–¥–∞–π—Ç–µ –≤–æ–ø—Ä–æ—Å –ò–ò..." @keyup.enter="sendMessage"
./src/components/chat/AIChatTab.vue:          <div v-for="(attachment, index) in currentAttachments" :key="index" class="current-attachment">
./src/components/chat/AIChatTab.vue:@keyframes slideIn {
./src/components/chat/AIChatTab.vue:@keyframes blink {
./src/components/chat/AIChatTab.vue:@keyframes pulse {
./src/components/chat/DeepAssistantPanel.vue:              :key="index"
./src/components/chat/AgentStatusIndicator.vue:        :key="`${agent.name}-${index}`"
./src/components/chat/AgentStatusIndicator.vue:@keyframes blink {
./src/components/chat/CodeExecutionWindow.vue:        <TabPanel v-for="(exec, index) in executions" :key="exec.id" :header="exec.title">
./src/components/chat/CodeExecutionWindow.vue:                <Tag v-for="dep in exec.dependencies" :key="dep" :value="dep" class="dep-tag" />
./src/components/chat/ClaudeCodeChat.vue:          <div v-for="file in gitStatus.files" :key="file.filepath" class="git-file">
./src/components/chat/ClaudeCodeChat.vue:        :key="index"
./src/components/chat/ClaudeCodeChat.vue:        @keyup.enter="sendMessage"
./src/components/chat/ClaudeCodeChat.vue:@keyframes blink {
./src/components/chat/ChatHistoryDialog.vue:        <div v-for="(chat, index) in savedChats" :key="index" class="chat-card">
./src/components/chat/ChatHistoryDialog.vue:@keyframes float {
./src/components/chat/ChatHistoryDialog.vue:@keyframes fadeInUp {
./src/components/chat/ClaudeCodeTab.vue:          <div v-for="file in gitStatus.files" :key="file.filepath" class="git-file">
./src/components/chat/ClaudeCodeTab.vue:        :key="index"
./src/components/chat/ClaudeCodeTab.vue:        @keyup.enter="sendMessage"
./src/components/chat/ClaudeCodeTab.vue:@keyframes blink {
./src/components/chat/AvailableAgentsList.vue:        :key="agent.id"
./src/components/chat/AvailableAgentsList.vue:              :key="capability"
./src/views/pages/auth/Login.vue:import { getDefaultToken } from '@/services/tokenService'
./src/views/pages/auth/Login.vue:const password = ref('')
./src/views/pages/auth/Login.vue:  // This was causing tokens to be deleted after successful login when user is redirected.
./src/views/pages/auth/Login.vue:  // The Login component may still be mounted during redirect, causing token deletion.
./src/views/pages/auth/Login.vue:  // localStorage.removeItem('token')  // REMOVED
./src/views/pages/auth/Login.vue:  const cookiesToCheck = ['_xsrf', 'token', 'id', 'user']
./src/views/pages/auth/Login.vue:    await authStore.login(email.value, password.value, finalApiBase, finalDatabase)
./src/views/pages/auth/Login.vue:    // Fetch default token to show balance in welcome message
./src/views/pages/auth/Login.vue:    let tokenBalance = null
./src/views/pages/auth/Login.vue:      const userToken = localStorage.getItem('token') || authStore.token
./src/views/pages/auth/Login.vue:        const tokenData = await getDefaultToken(userToken)
./src/views/pages/auth/Login.vue:        tokenBalance = tokenData.token?.token_balance
./src/views/pages/auth/Login.vue:    } catch (tokenError) {
./src/views/pages/auth/Login.vue:      console.warn('Failed to fetch token balance:', tokenError)
./src/views/pages/auth/Login.vue:    // Show welcome toast with token balance if available
./src/views/pages/auth/Login.vue:      detail: tokenBalance
./src/views/pages/auth/Login.vue:        ? `–í–∞—à –±–∞–ª–∞–Ω—Å: ${tokenBalance.toLocaleString('ru-RU')} —Ç–æ–∫–µ–Ω–æ–≤. –í—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å AI –º–æ–¥–µ–ª–∏ –±–µ—Å–ø–ª–∞—Ç–Ω–æ!`
./src/views/pages/auth/Login.vue:      const { userId, username, displayName, accessToken, refreshToken, token, _xsrf } = response.data.data
./src/views/pages/auth/Login.vue:      // Save tokens to localStorage
./src/views/pages/auth/Login.vue:      if (token) localStorage.setItem('token', token)
./src/views/pages/auth/Login.vue:              <label for="password1"
./src/views/pages/auth/Login.vue:              <Password id="password1" v-model="password" placeholder="–ü–∞—Ä–æ–ª—å" :toggleMask="true" class="mb-3" fluid
./src/views/pages/auth/Register.vue:const password = ref('')
./src/views/pages/auth/Register.vue:      // Save tokens
./src/views/pages/auth/Register.vue:  if (!login.value || !email.value || !password.value || !confirmPassword.value) return (errorMessage.value = '–í—Å–µ –ø–æ–ª—è –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∑–∞–ø–æ–ª–Ω–µ–Ω—ã') && false
./src/views/pages/auth/Register.vue:  if (password.value !== confirmPassword.value) return (errorMessage.value = '–ü–∞—Ä–æ–ª–∏ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç') && false
./src/views/pages/auth/Register.vue:  if (password.value.length < 8) return (errorMessage.value = '–ü–∞—Ä–æ–ª—å –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 8 —Å–∏–º–≤–æ–ª–æ–≤') && false
./src/views/pages/auth/Register.vue:      password: password.value,
./src/views/pages/auth/Register.vue:      // Store tokens and user data
./src/views/pages/auth/Register.vue:      // Save tokens
./src/views/pages/auth/Register.vue:                            <label for="password"
./src/views/pages/auth/Register.vue:                            <Password id="password" v-model="password" placeholder="–°–æ–∑–¥–∞–π—Ç–µ –ø–∞—Ä–æ–ª—å" :toggleMask="true"
./src/views/pages/auth/Register.vue:.p-password {
./src/views/pages/auth/EmailVerify.vue:        <div class="token-gift-box">
./src/views/pages/auth/EmailVerify.vue:          <p class="token-message">
./src/views/pages/auth/EmailVerify.vue:            <span class="token-balance">1,000,000 —Ç–æ–∫–µ–Ω–æ–≤</span>
./src/views/pages/auth/EmailVerify.vue:          <p class="token-description">
./src/views/pages/auth/EmailVerify.vue:            <li v-for="db in verificationResult.databases" :key="db.database">
./src/views/pages/auth/EmailVerify.vue:  const token = route.query.token;
./src/views/pages/auth/EmailVerify.vue:  if (token) {
./src/views/pages/auth/EmailVerify.vue:    await handleVerification(token);
./src/views/pages/auth/EmailVerify.vue:async function handleVerification(token) {
./src/views/pages/auth/EmailVerify.vue:    const result = await verifyEmail(token);
./src/views/pages/auth/EmailVerify.vue:    // Note: resendVerification requires email and password
./src/views/pages/auth/EmailVerify.vue:    // Since we don't have password here, we need to ask user to re-register
./src/views/pages/auth/EmailVerify.vue:  // Redirect to login first, then to tokens
./src/views/pages/auth/EmailVerify.vue:  router.push('/login?redirect=/tokens');
./src/views/pages/auth/EmailVerify.vue:@keyframes spin {
./src/views/pages/auth/EmailVerify.vue:.token-gift-box {
./src/views/pages/auth/EmailVerify.vue:@keyframes slideIn {
./src/views/pages/auth/EmailVerify.vue:@keyframes bounce {
./src/views/pages/auth/EmailVerify.vue:.token-gift-box h3 {
./src/views/pages/auth/EmailVerify.vue:.token-message {
./src/views/pages/auth/EmailVerify.vue:.token-balance {
./src/views/pages/auth/EmailVerify.vue:.token-description {
./src/views/pages/auth/EmailVerify.vue:.token-button {
./src/views/pages/auth/EmailVerify.vue:.token-button:hover {
./src/views/pages/auth/EmailVerify.vue:@keyframes pulse {
./src/views/pages/auth/OAuthCallback.vue:  // Issue #5112: Handle both JWT and Integram tokens from OAuth callback
./src/views/pages/auth/OAuthCallback.vue:  const { accessToken, refreshToken, userId, token, _xsrf, error } = route.query
./src/views/pages/auth/OAuthCallback.vue:    // Success - store JWT tokens
./src/views/pages/auth/OAuthCallback.vue:    if (token) localStorage.setItem('token', token)
./src/views/pages/auth/OAuthCallback.vue:    // No tokens - redirect to login
./src/views/pages/auth/EmailRegister.vue:            <label for="password">–ü–∞—Ä–æ–ª—å <span class="required">*</span></label>
./src/views/pages/auth/EmailRegister.vue:            <div class="password-input-wrapper">
./src/views/pages/auth/EmailRegister.vue:                id="password"
./src/views/pages/auth/EmailRegister.vue:                v-model="formData.password"
./src/views/pages/auth/EmailRegister.vue:                :type="showPassword ? 'text' : 'password'"
./src/views/pages/auth/EmailRegister.vue:                class="toggle-password"
./src/views/pages/auth/EmailRegister.vue:              :type="showPassword ? 'text' : 'password'"
./src/views/pages/auth/EmailRegister.vue:  password: ''
./src/views/pages/auth/EmailRegister.vue:    password: ''
./src/views/pages/auth/EmailRegister.vue:    formData.value.password &&
./src/views/pages/auth/EmailRegister.vue:    formData.value.password.length >= 8 &&
./src/views/pages/auth/EmailRegister.vue:    formData.value.password === confirmPassword.value
./src/views/pages/auth/EmailRegister.vue:  if (formData.value.password !== confirmPassword.value) {
./src/views/pages/auth/EmailRegister.vue:      password: formData.value.password,
./src/views/pages/auth/EmailRegister.vue:    // Clear password fields for security after successful registration
./src/views/pages/auth/EmailRegister.vue:    formData.value.password = '';
./src/views/pages/auth/EmailRegister.vue:      password: formData.value.password,
./src/views/pages/auth/EmailRegister.vue:.password-input-wrapper {
./src/views/pages/auth/EmailRegister.vue:.toggle-password {
./src/views/pages/auth/EmailRegister.vue:@keyframes spin {
./src/views/pages/Welcome.vue:              :key="video.id"
./src/views/pages/Welcome.vue:              :key="doc.id"
./src/views/pages/Welcome.vue:                  :key="module.id"
./src/views/pages/Landing.vue:  ;['_xsrf', 'token', 'user', 'id'].forEach(key => localStorage.removeItem(key))
./src/views/pages/Landing.vue:  keywords: '—É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã–º–∏, –±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö, integram, –∏–Ω—Ç–µ–≥—Ä–∞–º, —Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö, –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö, –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö, –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞ –¥–∞–Ω–Ω—ã—Ö',
./src/views/pages/Integram/IntegramLogin.vue:              :key="db.name"
./src/views/pages/Integram/IntegramLogin.vue:              :key="dbName"
./src/views/pages/Integram/IntegramLogin.vue:            @keyup.enter="handleLogin"
./src/views/pages/Integram/IntegramLogin.vue:          <label for="password" class="block text-sm font-medium mb-2">{{ t('password') }}</label>
./src/views/pages/Integram/IntegramLogin.vue:            id="password"
./src/views/pages/Integram/IntegramLogin.vue:            v-model="loginForm.password"
./src/views/pages/Integram/IntegramLogin.vue:            :class="{ 'p-invalid': errors.password }"
./src/views/pages/Integram/IntegramLogin.vue:            @keyup.enter="handleLogin"
./src/views/pages/Integram/IntegramLogin.vue:          <small v-if="errors.password" class="p-error">{{ errors.password }}</small>
./src/views/pages/Integram/IntegramLogin.vue:          <label for="regPassword" class="block text-sm font-medium mb-2">{{ t('password') }}</label>
./src/views/pages/Integram/IntegramLogin.vue:            v-model="registerForm.password"
./src/views/pages/Integram/IntegramLogin.vue:            v-model="registerForm.password2"
./src/views/pages/Integram/IntegramLogin.vue:import Password from 'primevue/password'
./src/views/pages/Integram/IntegramLogin.vue:  password: ''
./src/views/pages/Integram/IntegramLogin.vue:  password: '',
./src/views/pages/Integram/IntegramLogin.vue:  password2: '',
./src/views/pages/Integram/IntegramLogin.vue:    resetPasswordTitle: 'Reset password',
./src/views/pages/Integram/IntegramLogin.vue:    password: 'Password',
./src/views/pages/Integram/IntegramLogin.vue:    resetPassword: 'Forgot password?',
./src/views/pages/Integram/IntegramLogin.vue:    repeatPassword: 'Repeat password',
./src/views/pages/Integram/IntegramLogin.vue:    resetInstructions: 'Enter your database name and login or email to receive a new password.',
./src/views/pages/Integram/IntegramLogin.vue:    sendPassword: 'Send password',
./src/views/pages/Integram/IntegramLogin.vue:    resetSuccess: 'New password sent to your email',
./src/views/pages/Integram/IntegramLogin.vue:    helpNoGoogle: 'Check your email for the registration link. You can also reset your password.',
./src/views/pages/Integram/IntegramLogin.vue:    password: '–ü–∞—Ä–æ–ª—å',
./src/views/pages/Integram/IntegramLogin.vue:const t = (key) => translations[locale.value]?.[key] || key
./src/views/pages/Integram/IntegramLogin.vue:      password: ''
./src/views/pages/Integram/IntegramLogin.vue:  if (!loginForm.value.password) errors.value.password = '–û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ –ø–æ–ª–µ'
./src/views/pages/Integram/IntegramLogin.vue:  return Object.keys(errors.value).length === 0
./src/views/pages/Integram/IntegramLogin.vue:  if (!registerForm.value.password || registerForm.value.password.length < 6) {
./src/views/pages/Integram/IntegramLogin.vue:  if (registerForm.value.password !== registerForm.value.password2) {
./src/views/pages/Integram/IntegramLogin.vue:  return Object.keys(errors.value).length === 0
./src/views/pages/Integram/IntegramLogin.vue:  return Object.keys(errors.value).length === 0
./src/views/pages/Integram/IntegramLogin.vue:      loginForm.value.password
./src/views/pages/Integram/IntegramLogin.vue:      integramService.authToken = result.token
./src/views/pages/Integram/IntegramLogin.vue:      localStorage.setItem('token', result.token)
./src/views/pages/Integram/IntegramLogin.vue:      password: registerForm.value.password,
./src/views/pages/Integram/IntegramLogin.vue:        registerForm.value = { email: '', password: '', password2: '', agree: false }
./src/views/pages/Integram/IntegramLogin.vue::deep(.p-password-input) {
./src/views/pages/Integram/IntegramObjectEdit.vue:              :key="reqId"
./src/views/pages/Integram/IntegramObjectEdit.vue:                        :key="item.id || item.ref"
./src/views/pages/Integram/IntegramObjectEdit.vue:    if (!authInfo || !authInfo.token) {
./src/views/pages/Integram/IntegramOAuthCallback.vue:function t(key) {
./src/views/pages/Integram/IntegramOAuthCallback.vue:  return translations[locale.value]?.[key] || key;
./src/views/pages/Integram/IntegramOAuthCallback.vue:      localStorage.setItem('token', result.token);
./src/views/pages/Integram/IntegramOAuthCallback.vue:@keyframes fadeIn {
./src/views/pages/Integram/IntegramApiDocs.vue:            :key="cat.value"
./src/views/pages/Integram/IntegramApiDocs.vue:            :key="subcat"
./src/views/pages/Integram/IntegramApiDocs.vue:                            <span class="param-key">val</span>
./src/views/pages/Integram/IntegramApiDocs.vue:                            <span class="param-key">t</span>
./src/views/pages/Integram/IntegramApiDocs.vue:                            <span class="param-key">unique</span>
./src/views/pages/Integram/IntegramApiDocs.vue:                            <span class="param-key">t</span>
./src/views/pages/Integram/IntegramApiDocs.vue:                            <span class="param-key">val</span>
./src/views/pages/Integram/IntegramApiDocs.vue:                            <span class="param-key">t12345</span>
./src/views/pages/Integram/IntegramApiDocs.vue:                            <span class="param-key">t12346</span>
./src/views/pages/Integram/IntegramApiDocs.vue:                            <span class="param-key">up</span>
./src/views/pages/Integram/IntegramApiDocs.vue:                            <span class="param-key">t12346</span>
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">serverURL</span>: <span class="mcp-string">"https://dronedoc.ru"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">database</span>: <span class="mcp-string">"my"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">login</span>: <span class="mcp-string">"user"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">password</span>: <span class="mcp-string">"pass"</span>
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">tableName</span>: <span class="mcp-string">"–ö–ª–∏–µ–Ω—Ç—ã"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">columns</span>: [
./src/views/pages/Integram/IntegramApiDocs.vue:    { <span class="mcp-key">alias</span>: <span class="mcp-string">"Email"</span>, <span class="mcp-key">requisiteTypeId</span>: <span class="mcp-number">3</span> },
./src/views/pages/Integram/IntegramApiDocs.vue:    { <span class="mcp-key">alias</span>: <span class="mcp-string">"–¢–µ–ª–µ—Ñ–æ–Ω"</span>, <span class="mcp-key">requisiteTypeId</span>: <span class="mcp-number">3</span> },
./src/views/pages/Integram/IntegramApiDocs.vue:    { <span class="mcp-key">alias</span>: <span class="mcp-string">"–ë–∞–ª–∞–Ω—Å"</span>, <span class="mcp-key">requisiteTypeId</span>: <span class="mcp-number">13</span> }
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">tableName</span>: <span class="mcp-string">"–°—Ç–∞—Ç—É—Å—ã"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">values</span>: [<span class="mcp-string">"–ù–æ–≤—ã–π"</span>, <span class="mcp-string">"–ê–∫—Ç–∏–≤–Ω—ã–π"</span>, <span class="mcp-string">"–ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω"</span>]
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">tables</span>: [{ <span class="mcp-key">id</span>: <span class="mcp-number">18</span>, <span class="mcp-key">alias</span>: <span class="mcp-string">"u"</span> }],
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">columns</span>: [
./src/views/pages/Integram/IntegramApiDocs.vue:    { <span class="mcp-key">field</span>: <span class="mcp-number">18</span>, <span class="mcp-key">name</span>: <span class="mcp-string">"–ò–º—è"</span> },
./src/views/pages/Integram/IntegramApiDocs.vue:    { <span class="mcp-key">field</span>: <span class="mcp-number">115</span>, <span class="mcp-key">name</span>: <span class="mcp-string">"Email"</span> }
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">where</span>: <span class="mcp-string">"u.115 IS NOT NULL"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">limit</span>: <span class="mcp-number">50</span>
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">tables</span>: [{ <span class="mcp-key">id</span>: <span class="mcp-number">12360</span>, <span class="mcp-key">alias</span>: <span class="mcp-string">"o"</span> }],
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">columns</span>: [
./src/views/pages/Integram/IntegramApiDocs.vue:    { <span class="mcp-key">field</span>: <span class="mcp-number">12363</span>, <span class="mcp-key">name</span>: <span class="mcp-string">"–°—Ç–∞—Ç—É—Å"</span>, <span class="mcp-key">groupBy</span>: <span class="mcp-boolean">true</span> },
./src/views/pages/Integram/IntegramApiDocs.vue:    { <span class="mcp-key">field</span>: <span class="mcp-number">0</span>, <span class="mcp-key">formula</span>: <span class="mcp-string">"COUNT(*)"</span>, <span class="mcp-key">name</span>: <span class="mcp-string">"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ"</span> }
./src/views/pages/Integram/IntegramApiDocs.vue:                      <pre class="js-code"><span class="js-keyword">import</span> integramApiClient <span class="js-keyword">from</span> <span class="js-string">'@/services/integramApiClient'</span></pre>
./src/views/pages/Integram/IntegramApiDocs.vue:                      <pre class="js-code"><span class="js-keyword">await</span> integramApiClient.<span class="js-function">setServer</span>(<span class="js-string">'https://dronedoc.ru'</span>)
./src/views/pages/Integram/IntegramApiDocs.vue:<span class="js-keyword">await</span> integramApiClient.<span class="js-function">authenticate</span>(<span class="js-string">'A2025'</span>, <span class="js-string">'user'</span>, <span class="js-string">'password'</span>)</pre>
./src/views/pages/Integram/IntegramApiDocs.vue:                      <pre class="js-code"><span class="js-keyword">const</span> dict = <span class="js-keyword">await</span> integramApiClient.<span class="js-function">getDictionary</span>()</pre>
./src/views/pages/Integram/IntegramApiDocs.vue:                      <pre class="js-code"><span class="js-keyword">const</span> objects = <span class="js-keyword">await</span> integramApiClient.<span class="js-function">getObjectList</span>(<span class="js-number">18</span>, { <span class="js-key">LIMIT</span>: <span class="js-number">50</span> })</pre>
./src/views/pages/Integram/IntegramApiDocs.vue:                      <pre class="js-code"><span class="js-keyword">const</span> result = <span class="js-keyword">await</span> integramApiClient.<span class="js-function">createObject</span>(<span class="js-number">18</span>, <span class="js-string">'–ù–∞–∑–≤–∞–Ω–∏–µ'</span>, {
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="json-key">"_xsrf"</span>: <span class="json-string">"ef1bbd56839b1e97636a5"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="json-key">"token"</span>: <span class="json-string">"67a450965bf763cd719b5fcdb4ca41"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="json-key">"msg"</span>: <span class="json-null">null</span>
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="json-key">"failed"</span>: <span class="json-string">"wrong"</span>
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="json-key">"id"</span>: <span class="json-string">"18"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="json-key">"up"</span>: <span class="json-string">"0"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="json-key">"type"</span>: <span class="json-string">"3"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="json-key">"val"</span>: <span class="json-string">"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="json-key">"unique"</span>: <span class="json-string">"1"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="json-key">"reqs"</span>: [
./src/views/pages/Integram/IntegramApiDocs.vue:      <span class="json-key">"num"</span>: <span class="json-number">1</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:      <span class="json-key">"id"</span>: <span class="json-string">"115"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:      <span class="json-key">"val"</span>: <span class="json-string">"–†–æ–ª—å"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:      <span class="json-key">"type"</span>: <span class="json-string">"3"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:      <span class="json-key">"ref"</span>: <span class="json-string">"42"</span>,        <span class="json-comment">// –°—Å—ã–ª–∫–∞ –Ω–∞ —Ç–∞–±–ª–∏—Ü—É 42</span>
./src/views/pages/Integram/IntegramApiDocs.vue:      <span class="json-key">"ref_id"</span>: <span class="json-string">"114"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:      <span class="json-key">"attrs"</span>: <span class="json-string">":!NULL:164"</span>  <span class="json-comment">// !NULL = –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ</span>
./src/views/pages/Integram/IntegramApiDocs.vue:      <span class="json-key">"num"</span>: <span class="json-number">2</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:      <span class="json-key">"id"</span>: <span class="json-string">"41"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:      <span class="json-key">"val"</span>: <span class="json-string">"Email"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:      <span class="json-key">"type"</span>: <span class="json-string">"3"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:      <span class="json-key">"attrs"</span>: <span class="json-string">":!NULL:"</span>
./src/views/pages/Integram/IntegramApiDocs.vue:      <span class="json-key">"num"</span>: <span class="json-number">3</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:      <span class="json-key">"id"</span>: <span class="json-string">"156"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:      <span class="json-key">"val"</span>: <span class="json-string">"–î–∞—Ç–∞"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:      <span class="json-key">"type"</span>: <span class="json-string">"9"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:      <span class="json-key">"attrs"</span>: <span class="json-string">"[TODAY]"</span>  <span class="json-comment">// –ó–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é</span>
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="json-key">"type"</span>: {
./src/views/pages/Integram/IntegramApiDocs.vue:    <span class="json-key">"id"</span>: <span class="json-number">1141</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:    <span class="json-key">"up"</span>: <span class="json-number">1</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:    <span class="json-key">"val"</span>: <span class="json-string">"Plan"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:    <span class="json-key">"base"</span>: <span class="json-string">"SHORT"</span>
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="json-key">"base"</span>: { <span class="json-key">"id"</span>: <span class="json-string">"3"</span> },
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="json-key">"req_base"</span>: { <span class="json-key">"1274"</span>: <span class="json-string">"SIGNED"</span> },
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="json-key">"req_type"</span>: { <span class="json-key">"1274"</span>: <span class="json-string">"Price"</span> },
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="json-key">"req_order"</span>: [<span class="json-string">"1274"</span>],
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="json-key">"object"</span>: [
./src/views/pages/Integram/IntegramApiDocs.vue:    { <span class="json-key">"id"</span>: <span class="json-string">"1146"</span>, <span class="json-key">"up"</span>: <span class="json-string">"1"</span>, <span class="json-key">"val"</span>: <span class="json-string">"Free"</span>, <span class="json-key">"base"</span>: <span class="json-string">"1141"</span> },
./src/views/pages/Integram/IntegramApiDocs.vue:    { <span class="json-key">"id"</span>: <span class="json-string">"1148"</span>, <span class="json-key">"up"</span>: <span class="json-string">"1"</span>, <span class="json-key">"val"</span>: <span class="json-string">"Scalable"</span>, <span class="json-key">"base"</span>: <span class="json-string">"1141"</span> }
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="json-key">"reqs"</span>: {
./src/views/pages/Integram/IntegramApiDocs.vue:    <span class="json-key">"1146"</span>: { <span class="json-key">"1274"</span>: <span class="json-string">"0.00"</span> },
./src/views/pages/Integram/IntegramApiDocs.vue:    <span class="json-key">"1148"</span>: { <span class="json-key">"1274"</span>: <span class="json-string">"1950.00"</span> }
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="json-key">"_xsrf"</span>: <span class="json-string">"2ae0f4375dabb5"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="json-key">"token"</span>: <span class="json-string">"b4ad9d6b31a7c82972ef1b2"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="json-key">"user"</span>: <span class="json-string">"admin"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="json-key">"role"</span>: <span class="json-string">"admin"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="json-key">"id"</span>: <span class="json-string">"130152"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="json-key">"msg"</span>: <span class="json-string">""</span>
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">typeId</span>: <span class="mcp-number">195629</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">objects</span>: [
./src/views/pages/Integram/IntegramApiDocs.vue:      <span class="mcp-key">value</span>: <span class="mcp-string">"–ì–ª–∞–≤–Ω–∞—è"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:      <span class="mcp-key">requisites</span>: { <span class="mcp-string">"195630"</span>: <span class="mcp-string">"/"</span>, <span class="mcp-string">"195631"</span>: <span class="mcp-string">"pi pi-home"</span> }
./src/views/pages/Integram/IntegramApiDocs.vue:      <span class="mcp-key">value</span>: <span class="mcp-string">"–ü—Ä–æ—Ñ–∏–ª—å"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:      <span class="mcp-key">requisites</span>: { <span class="mcp-string">"195630"</span>: <span class="mcp-string">"/profile"</span>, <span class="mcp-string">"195631"</span>: <span class="mcp-string">"pi pi-user"</span> }
./src/views/pages/Integram/IntegramApiDocs.vue:      <span class="mcp-key">value</span>: <span class="mcp-string">"–ù–∞—Å—Ç—Ä–æ–π–∫–∏"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:      <span class="mcp-key">requisites</span>: { <span class="mcp-string">"195630"</span>: <span class="mcp-string">"/settings"</span>, <span class="mcp-string">"195631"</span>: <span class="mcp-string">"pi pi-cog"</span> }
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">parentTypeId</span>: <span class="mcp-number">22</span>,      <span class="mcp-comment">// –û—Ç—á–µ—Ç</span>
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">parentValue</span>: <span class="mcp-string">"–ü—Ä–æ–¥–∞–∂–∏ –ø–æ –º–µ–Ω–µ–¥–∂–µ—Ä–∞–º"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">parentRequisites</span>: { <span class="mcp-string">"228"</span>: <span class="mcp-string">"1"</span> },  <span class="mcp-comment">// EXECUTE flag</span>
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">childTypeId</span>: <span class="mcp-number">28</span>,       <span class="mcp-comment">// –ö–æ–ª–æ–Ω–∫–∏ –æ—Ç—á–µ—Ç–∞</span>
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">children</span>: [
./src/views/pages/Integram/IntegramApiDocs.vue:    { <span class="mcp-key">value</span>: <span class="mcp-string">"–ú–µ–Ω–µ–¥–∂–µ—Ä"</span>, <span class="mcp-key">requisites</span>: { <span class="mcp-string">"100"</span>: <span class="mcp-string">"–ú–µ–Ω–µ–¥–∂–µ—Ä"</span> } },
./src/views/pages/Integram/IntegramApiDocs.vue:    { <span class="mcp-key">value</span>: <span class="mcp-string">"–°—É–º–º–∞"</span>, <span class="mcp-key">requisites</span>: { <span class="mcp-string">"100"</span>: <span class="mcp-string">"–°—É–º–º–∞"</span>, <span class="mcp-string">"72"</span>: <span class="mcp-string">"1"</span> } }
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">objectId</span>: <span class="mcp-number">197070</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">requisiteId</span>: <span class="mcp-number">197038</span>,  <span class="mcp-comment">// multiselect —Ä–µ–∫–≤–∏–∑–∏—Ç</span>
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">value</span>: <span class="mcp-string">"197039"</span>       <span class="mcp-comment">// ID –≤—ã–±–∏—Ä–∞–µ–º–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞</span>
./src/views/pages/Integram/IntegramApiDocs.vue:                        <pre class="mcp-code"><span class="js-keyword">const</span> items = <span class="mcp-function">integram_get_multiselect_items</span>({
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">objectId</span>: <span class="mcp-number">197070</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">requisiteId</span>: <span class="mcp-number">197038</span>
./src/views/pages/Integram/IntegramApiDocs.vue:  { <span class="json-key">"id"</span>: <span class="json-string">"123"</span>, <span class="json-key">"value"</span>: <span class="json-string">"197039"</span> },
./src/views/pages/Integram/IntegramApiDocs.vue:  { <span class="json-key">"id"</span>: <span class="json-string">"124"</span>, <span class="json-key">"value"</span>: <span class="json-string">"197040"</span> }
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">itemId</span>: <span class="mcp-string">"123"</span>  <span class="mcp-comment">// –ù–ï objectId, –∞ ID —Å–≤—è–∑–∏!</span>
./src/views/pages/Integram/IntegramApiDocs.vue:                        <pre class="mcp-code"><span class="js-keyword">const</span> structure = <span class="mcp-function">integram_get_table_structure</span>({
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">typeId</span>: <span class="mcp-number">195629</span>
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">sourceTypeId</span>: <span class="mcp-number">195629</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">newTableName</span>: <span class="mcp-string">"–ë–æ–∫–æ–≤–æ–µ–ú–µ–Ω—é_–ö–æ–ø–∏—è"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">baseTypeId</span>: <span class="mcp-number">3</span>
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">typeId</span>: <span class="mcp-number">195629</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">newName</span>: <span class="mcp-string">"–ì–ª–∞–≤–Ω–æ–µ–ú–µ–Ω—é"</span>
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">typeId</span>: <span class="mcp-number">195629</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">columns</span>: [
./src/views/pages/Integram/IntegramApiDocs.vue:    { <span class="mcp-key">alias</span>: <span class="mcp-string">"–û–ø–∏—Å–∞–Ω–∏–µ"</span>, <span class="mcp-key">requisiteTypeId</span>: <span class="mcp-number">2</span>, <span class="mcp-key">allowNull</span>: <span class="mcp-boolean">true</span> },
./src/views/pages/Integram/IntegramApiDocs.vue:    { <span class="mcp-key">alias</span>: <span class="mcp-string">"–ê–∫—Ç–∏–≤–µ–Ω"</span>, <span class="mcp-key">requisiteTypeId</span>: <span class="mcp-number">7</span>, <span class="mcp-key">allowNull</span>: <span class="mcp-boolean">false</span> },
./src/views/pages/Integram/IntegramApiDocs.vue:    { <span class="mcp-key">alias</span>: <span class="mcp-string">"–ü–æ—Ä—è–¥–æ–∫"</span>, <span class="mcp-key">requisiteTypeId</span>: <span class="mcp-number">13</span> }
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">typeId</span>: <span class="mcp-number">195629</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">confirm</span>: <span class="mcp-boolean">true</span>  <span class="mcp-comment">// –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ</span>
./src/views/pages/Integram/IntegramApiDocs.vue:                        <pre class="mcp-code"><span class="js-keyword">const</span> reportId = <span class="mcp-function">integram_create_report</span>({
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">name</span>: <span class="mcp-string">"–ö–ª–∏–µ–Ω—Ç—ã —Å –∑–∞–∫–∞–∑–∞–º–∏"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">fromTables</span>: [
./src/views/pages/Integram/IntegramApiDocs.vue:    { <span class="mcp-key">tableId</span>: <span class="mcp-number">204210</span>, <span class="mcp-key">alias</span>: <span class="mcp-string">"c"</span> },
./src/views/pages/Integram/IntegramApiDocs.vue:    { <span class="mcp-key">tableId</span>: <span class="mcp-number">204220</span>, <span class="mcp-key">alias</span>: <span class="mcp-string">"o"</span>, <span class="mcp-key">joinOn</span>: <span class="mcp-string">"o.client_id = c.id"</span> }
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">columns</span>: [
./src/views/pages/Integram/IntegramApiDocs.vue:    { <span class="mcp-key">field</span>: <span class="mcp-number">204210</span>, <span class="mcp-key">name</span>: <span class="mcp-string">"–ö–ª–∏–µ–Ω—Ç"</span> },
./src/views/pages/Integram/IntegramApiDocs.vue:    { <span class="mcp-key">field</span>: <span class="mcp-number">0</span>, <span class="mcp-key">formula</span>: <span class="mcp-string">"COUNT(o.id)"</span>, <span class="mcp-key">name</span>: <span class="mcp-string">"–ó–∞–∫–∞–∑–æ–≤"</span> }
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">where</span>: <span class="mcp-string">"c.active = 1"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">orderBy</span>: <span class="mcp-string">"c.name"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">limit</span>: <span class="mcp-number">100</span>
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">reportId</span>: <span class="mcp-number">12345</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">fieldId</span>: <span class="mcp-number">204214</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">nameInReport</span>: <span class="mcp-string">"–¢–µ–ª–µ—Ñ–æ–Ω"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">formula</span>: <span class="mcp-string">"c.phone"</span>
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">sourceReportId</span>: <span class="mcp-number">12345</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">newName</span>: <span class="mcp-string">"–ö–ª–∏–µ–Ω—Ç—ã —Å –∑–∞–∫–∞–∑–∞–º–∏ (–∫–æ–ø–∏—è)"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">setExecute</span>: <span class="mcp-boolean">true</span>
./src/views/pages/Integram/IntegramApiDocs.vue:                        <pre class="mcp-code"><span class="js-keyword">const</span> reportStructure = <span class="mcp-function">integram_get_report_structure</span>({
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">reportId</span>: <span class="mcp-number">12345</span>
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">targetTableId</span>: <span class="mcp-number">195629</span>,        <span class="mcp-comment">// –¢–∞–±–ª–∏—Ü–∞ –ë–æ–∫–æ–≤–æ–µ–ú–µ–Ω—é</span>
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">lookupTableName</span>: <span class="mcp-string">"–°—Ç–∞—Ç—É—Å—ã –º–µ–Ω—é"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">values</span>: [<span class="mcp-string">"–ê–∫—Ç–∏–≤–Ω—ã–π"</span>, <span class="mcp-string">"–°–∫—Ä—ã—Ç—ã–π"</span>, <span class="mcp-string">"–£–¥–∞–ª–µ–Ω"</span>],
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">columnAlias</span>: <span class="mcp-string">"–°—Ç–∞—Ç—É—Å"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">multiSelect</span>: <span class="mcp-boolean">false</span>
./src/views/pages/Integram/IntegramApiDocs.vue:                        <pre class="mcp-code"><span class="js-keyword">const</span> lookupId = <span class="mcp-function">integram_create_lookup_table</span>({
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">tableName</span>: <span class="mcp-string">"–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç—ã"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">values</span>: [<span class="mcp-string">"–ù–∏–∑–∫–∏–π"</span>, <span class="mcp-string">"–°—Ä–µ–¥–Ω–∏–π"</span>, <span class="mcp-string">"–í—ã—Å–æ–∫–∏–π"</span>, <span class="mcp-string">"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π"</span>],
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">unique</span>: <span class="mcp-boolean">true</span>
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">typeId</span>: <span class="mcp-number">195629</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">referenceTableId</span>: lookupId,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">alias</span>: <span class="mcp-string">"–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">multiSelect</span>: <span class="mcp-boolean">false</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">allowNull</span>: <span class="mcp-boolean">true</span>
./src/views/pages/Integram/IntegramApiDocs.vue:                        <pre class="mcp-code"><span class="js-keyword">const</span> allTypes = <span class="mcp-function">integram_get_all_types_metadata</span>()</pre>
./src/views/pages/Integram/IntegramApiDocs.vue:                        <pre class="mcp-code"><span class="js-keyword">const</span> count = <span class="mcp-function">integram_get_object_count</span>({ <span class="mcp-key">typeId</span>: <span class="mcp-number">195629</span> })</pre>
./src/views/pages/Integram/IntegramApiDocs.vue:                        <pre class="json-code">{ <span class="json-key">"count"</span>: <span class="json-number">42</span> }</pre>
./src/views/pages/Integram/IntegramApiDocs.vue:                        <pre class="mcp-code"><span class="js-keyword">const</span> objMeta = <span class="mcp-function">integram_get_object_meta</span>({
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">objectId</span>: <span class="mcp-number">197070</span>
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="json-key">"type"</span>: <span class="json-number">195629</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="json-key">"parent"</span>: <span class="json-number">1</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="json-key">"created"</span>: <span class="json-string">"..."</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="json-key">"modified"</span>: <span class="json-string">"..."</span>
./src/views/pages/Integram/IntegramApiDocs.vue:                        <pre class="mcp-code"><span class="js-keyword">const</span> schema = <span class="mcp-function">integram_get_schema</span>({
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">filter</span>: <span class="mcp-string">"–ú–µ–Ω—é"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:  <span class="mcp-key">includeSystemTables</span>: <span class="mcp-boolean">false</span>
./src/views/pages/Integram/IntegramApiDocs.vue:    <span class="json-key">"id"</span>: <span class="json-number">195629</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:    <span class="json-key">"name"</span>: <span class="json-string">"–ë–æ–∫–æ–≤–æ–µ–ú–µ–Ω—é"</span>,
./src/views/pages/Integram/IntegramApiDocs.vue:    <span class="json-key">"fields"</span>: [
./src/views/pages/Integram/IntegramApiDocs.vue:      { <span class="json-key">"id"</span>: <span class="json-number">195630</span>, <span class="json-key">"name"</span>: <span class="json-string">"path"</span>, <span class="json-key">"type"</span>: <span class="json-string">"SHORT"</span>, <span class="json-key">"ref"</span>: <span class="json-null">null</span> }
./src/views/pages/Integram/IntegramApiDocs.vue:                        <div class="param-col-key">KEY</div>
./src/views/pages/Integram/IntegramApiDocs.vue:                          :key="index"
./src/views/pages/Integram/IntegramApiDocs.vue:                          <div class="param-col-key">
./src/views/pages/Integram/IntegramApiDocs.vue:                              v-model="param.key"
./src/views/pages/Integram/IntegramApiDocs.vue:                              placeholder="key"
./src/views/pages/Integram/IntegramApiDocs.vue:    { key: '', value: '', enabled: true }
./src/views/pages/Integram/IntegramApiDocs.vue:–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç: xsrf token, user info, permissions`
./src/views/pages/Integram/IntegramApiDocs.vue:–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç: _xsrf, token, user, role, id`,
./src/views/pages/Integram/IntegramApiDocs.vue:      token: 'b4ad9d6b31a7c82972ef1b2',
./src/views/pages/Integram/IntegramApiDocs.vue:–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç: session cookie, xsrf token`,
./src/views/pages/Integram/IntegramApiDocs.vue:password ‚Äî –ø–∞—Ä–æ–ª—å`
./src/views/pages/Integram/IntegramApiDocs.vue:token ‚Äî session token
./src/views/pages/Integram/IntegramApiDocs.vue:    playground.value.params = Object.entries(command.exampleBody).map(([key, value]) => ({
./src/views/pages/Integram/IntegramApiDocs.vue:      key,
./src/views/pages/Integram/IntegramApiDocs.vue:    playground.value.params = [{ key: '', value: '', enabled: true }]
./src/views/pages/Integram/IntegramApiDocs.vue:        .filter(param => param.enabled && param.key.trim())
./src/views/pages/Integram/IntegramApiDocs.vue:          body[param.key.trim()] = param.value.trim()
./src/views/pages/Integram/IntegramApiDocs.vue:      { key: '', value: '', enabled: true }
./src/views/pages/Integram/IntegramApiDocs.vue:  playground.value.params.push({ key: '', value: '', enabled: true })
./src/views/pages/Integram/IntegramApiDocs.vue:  const key = rowData.cmd
./src/views/pages/Integram/IntegramApiDocs.vue:  if (expandedRows.value[key]) {
./src/views/pages/Integram/IntegramApiDocs.vue:    delete expandedRows.value[key]
./src/views/pages/Integram/IntegramApiDocs.vue:    expandedRows.value[key] = true
./src/views/pages/Integram/IntegramApiDocs.vue:.param-col-key,
./src/views/pages/Integram/IntegramApiDocs.vue:.param-key {
./src/views/pages/Integram/IntegramApiDocs.vue:.body-param .param-key {
./src/views/pages/Integram/IntegramApiDocs.vue:.mcp-key {
./src/views/pages/Integram/IntegramApiDocs.vue:.js-keyword {
./src/views/pages/Integram/IntegramApiDocs.vue:.js-key {
./src/views/pages/Integram/IntegramApiDocs.vue:.json-key {
./src/views/pages/Integram/IntegramTableList.vue:                @keydown="handleSearchKeydown"
./src/views/pages/Integram/IntegramTableList.vue:            :key="table.id"
./src/views/pages/Integram/IntegramTableList.vue:            @keyup.enter="createTable"
./src/views/pages/Integram/IntegramTableList.vue:            @keyup.enter="cloneTable"
./src/views/pages/Integram/IntegramTableList.vue:// Reset active index only when debounced search changes (not on every keystroke)
./src/views/pages/Integram/IntegramTableList.vue: * Handle keyboard navigation in search input
./src/views/pages/Integram/IntegramTableList.vue:  if (event.key === 'ArrowDown') {
./src/views/pages/Integram/IntegramTableList.vue:  } else if (event.key === 'ArrowUp') {
./src/views/pages/Integram/IntegramTableList.vue:  } else if (event.key === 'Enter') {
./src/views/pages/Integram/IntegramObjectView.vue:              <div v-for="req in requisites" :key="req.id" class="col-12 md:col-3">
./src/views/pages/Integram/IntegramObjectView.vue:                      @keydown.enter="saveEdit(slotProps.data)"
./src/views/pages/Integram/IntegramObjectView.vue:                      @keydown.esc="cancelEdit"
./src/views/pages/Integram/IntegramObjectView.vue:              :key="req.id"
./src/views/pages/Integram/IntegramObjectView.vue:                      @keydown.esc="cancelEdit"
./src/views/pages/Integram/IntegramObjectView.vue:                      @keydown.esc="cancelEdit"
./src/views/pages/Integram/IntegramObjectView.vue:                      @keydown.enter="saveEdit(slotProps.data, req.id)"
./src/views/pages/Integram/IntegramObjectView.vue:                      @keydown.esc="cancelEdit"
./src/views/pages/Integram/IntegramObjectView.vue:                      @keydown.enter="saveEdit(slotProps.data, req.id)"
./src/views/pages/Integram/IntegramObjectView.vue:                      @keydown.esc="cancelEdit"
./src/views/pages/Integram/IntegramObjectView.vue:                      @keydown.enter="saveEdit(slotProps.data, req.id)"
./src/views/pages/Integram/IntegramObjectView.vue:                      @keydown.esc="cancelEdit"
./src/views/pages/Integram/IntegramObjectView.vue:                      @keydown.esc="cancelEdit"
./src/views/pages/Integram/IntegramObjectView.vue:                      @keydown.enter="saveEdit(slotProps.data, req.id)"
./src/views/pages/Integram/IntegramObjectView.vue:                      @keydown.esc="cancelEdit"
./src/views/pages/Integram/IntegramObjectView.vue:        <div v-for="req in requisites" :key="req.id" class="field">
./src/views/pages/Integram/IntegramObjectView.vue:            <span v-for="(value, key) in filters" :key="key" v-if="key.startsWith('req_') && value">
./src/views/pages/Integram/IntegramObjectView.vue:              , {{ getRequisiteName(key) }}: "{{ value }}"
./src/views/pages/Integram/IntegramObjectView.vue:            @keyup="validateAddColumnForm"
./src/views/pages/Integram/IntegramObjectView.vue:    for (const key in filters.value) {
./src/views/pages/Integram/IntegramObjectView.vue:      if (key.startsWith('req_') && filters.value[key]) {
./src/views/pages/Integram/IntegramObjectView.vue:        const reqId = key.replace('req_', '');
./src/views/pages/Integram/IntegramObjectView.vue:        if (!value || !value.toLowerCase().includes(filters.value[key].toLowerCase())) {
./src/views/pages/Integram/IntegramObjectView.vue: * Displays all objects that reference this object via foreign keys
./src/views/pages/Integram/IntegramObjectView.vue:function getRequisiteName(key) {
./src/views/pages/Integram/IntegramObjectView.vue:  const reqId = key.replace('req_', '');
./src/views/pages/Integram/IntegramObjectView.vue:    // Build requisites object (key = reqId, value = formatted value)
./src/views/pages/Integram/IntegramObjectView.vue:    if (Object.keys(createForm.value.requisites).length > 0) {
./src/views/pages/Integram/IntegramObjectView.vue:      Object.keys(createForm.value.requisites).forEach(reqId => {
./src/views/pages/Integram/IntegramTypeEditor.vue:    if (!authInfo || !authInfo.token) {
./src/views/pages/Integram/IntegramTypeEditor.vue:      sessionId: authInfo.token,
./src/views/pages/Integram/IntegramDictionary.vue:          <div v-for="category in filteredCategories" :key="category.name" class="mb-4">
./src/views/pages/Integram/IntegramDictionary.vue:                :key="table.id"
./src/views/pages/Integram/IntegramDictionary.vue:                :key="table.id"
./src/views/pages/Integram/IntegramDictionary.vue:    const allTableIds = Object.keys(dict);
./src/views/pages/Integram/IntegramDictionary.vue:  // Home key (keyCode 36) focuses search input
./src/views/pages/Integram/IntegramDictionary.vue:  if (event.key === 'Home' && searchInputRef.value) {
./src/views/pages/Integram/IntegramDictionary.vue:  // Add keyboard navigation listener
./src/views/pages/Integram/IntegramDictionary.vue:  window.addEventListener('keydown', handleKeyDown);
./src/views/pages/Integram/IntegramDictionary.vue:  window.removeEventListener('keydown', handleKeyDown);
./src/views/pages/Integram/__tests__/IntegramObjectEdit.spec.js:      token: 'test_token',
./src/views/pages/Integram/UserProfile.vue:              <div v-for="field in displayFields" :key="field.id" class="field-row mb-3 p-3 surface-50 border-round">
./src/views/pages/Integram/UserProfile.vue:  if (userId.value && integramApiClient.token) {
./src/views/pages/Integram/IntegramLanding.vue:            :key="index"
./src/views/pages/Integram/IntegramLanding.vue:          <div v-for="(stat, key) in stats" :key="key" class="col-6 md:col-3 text-center">
./src/views/pages/Integram/IntegramLanding.vue:function t(key) {
./src/views/pages/Integram/IntegramLanding.vue:  return translations[locale.value]?.[key] || key
./src/views/pages/Integram/IntegramMain.vue:    <!-- Issue #5112: Add key to force component reload when database changes -->
./src/views/pages/Integram/IntegramMain.vue:      <SafeRouterView :key="database" />
./src/views/pages/Integram/IntegramMain.vue:      v-model:visible="passwordChangeVisible"
./src/views/pages/Integram/IntegramMain.vue:      :header="t('passwordChange')"
./src/views/pages/Integram/IntegramMain.vue:        <Message v-if="passwordMessage" :severity="passwordMessageSeverity">
./src/views/pages/Integram/IntegramMain.vue:          {{ passwordMessage }}
./src/views/pages/Integram/IntegramMain.vue:            @keyup.enter="changePassword"
./src/views/pages/Integram/IntegramMain.vue:            @keyup.enter="changePassword"
./src/views/pages/Integram/IntegramMain.vue:            @keyup.enter="changePassword"
./src/views/pages/Integram/IntegramMain.vue:          @click="passwordChangeVisible = false"
./src/views/pages/Integram/IntegramMain.vue:          :loading="passwordChanging"
./src/views/pages/Integram/IntegramMain.vue:const passwordChangeVisible = ref(false)
./src/views/pages/Integram/IntegramMain.vue:const passwordChanging = ref(false)
./src/views/pages/Integram/IntegramMain.vue:const passwordMessage = ref('')
./src/views/pages/Integram/IntegramMain.vue:const passwordMessageSeverity = ref('info')
./src/views/pages/Integram/IntegramMain.vue:    icon: 'pi pi-key',
./src/views/pages/Integram/IntegramMain.vue:function t(key) {
./src/views/pages/Integram/IntegramMain.vue:      passwordChange: '–°–º–µ–Ω–∞ –ø–∞—Ä–æ–ª—è',
./src/views/pages/Integram/IntegramMain.vue:      passwordsDoNotMatch: '–ü–∞—Ä–æ–ª–∏ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç',
./src/views/pages/Integram/IntegramMain.vue:      passwordChanged: '–ü–∞—Ä–æ–ª—å —É—Å–ø–µ—à–Ω–æ –∏–∑–º–µ–Ω—ë–Ω',
./src/views/pages/Integram/IntegramMain.vue:      passwordChange: 'Password Change',
./src/views/pages/Integram/IntegramMain.vue:      passwordsDoNotMatch: 'Passwords do not match',
./src/views/pages/Integram/IntegramMain.vue:      passwordChanged: 'Password changed successfully',
./src/views/pages/Integram/IntegramMain.vue:      wrongPassword: 'Wrong password',
./src/views/pages/Integram/IntegramMain.vue:  return translations[locale.value]?.[key] || key
./src/views/pages/Integram/IntegramMain.vue:  passwordChangeVisible.value = true
./src/views/pages/Integram/IntegramMain.vue:  passwordMessage.value = ''
./src/views/pages/Integram/IntegramMain.vue:    passwordMessage.value = t('fillAllFields')
./src/views/pages/Integram/IntegramMain.vue:    passwordMessageSeverity.value = 'error'
./src/views/pages/Integram/IntegramMain.vue:    passwordMessage.value = t('passwordsDoNotMatch')
./src/views/pages/Integram/IntegramMain.vue:    passwordMessageSeverity.value = 'error'
./src/views/pages/Integram/IntegramMain.vue:  passwordChanging.value = true
./src/views/pages/Integram/IntegramMain.vue:  passwordMessage.value = ''
./src/views/pages/Integram/IntegramMain.vue:    // Call Integram API to change password
./src/views/pages/Integram/IntegramMain.vue:      passwordMessage.value = t('passwordChanged')
./src/views/pages/Integram/IntegramMain.vue:      passwordMessageSeverity.value = 'success'
./src/views/pages/Integram/IntegramMain.vue:      // Update tokens if provided
./src/views/pages/Integram/IntegramMain.vue:      if (response.token) {
./src/views/pages/Integram/IntegramMain.vue:        integramApiClient.token = response.token
./src/views/pages/Integram/IntegramMain.vue:        passwordChangeVisible.value = false
./src/views/pages/Integram/IntegramMain.vue:      passwordMessage.value = errorMsg
./src/views/pages/Integram/IntegramMain.vue:      passwordMessageSeverity.value = 'error'
./src/views/pages/Integram/IntegramMain.vue:    passwordMessage.value = error.message || t('wrongPassword')
./src/views/pages/Integram/IntegramMain.vue:    passwordMessageSeverity.value = 'error'
./src/views/pages/Integram/IntegramMain.vue:    passwordChanging.value = false
./src/views/pages/Integram/IntegramMain.vue:  if (!authInfo.token || !authInfo.xsrf) {
./src/views/pages/Integram/IntegramMain.vue:  // Issue #5100: Validate session to refresh tokens and prevent quick expiration
./src/views/pages/Integram/MentionTestPage.vue:                    :key="index"
./src/views/pages/Integram/IntegrationReportPage.vue:          :key="index"
./src/views/pages/Integram/IntegrationReportPage.vue:          columns = Object.keys(response[0])
./src/views/pages/Integram/IntegramDatabaseSelector.vue:          :key="db.name"
./src/views/pages/Integram/IntegramDatabaseSelector.vue:          :key="dbName"
./src/views/pages/Integram/IntegramDatabaseSelector.vue:                <i class="pi pi-key"></i>
./src/views/pages/Integram/IntegramDatabaseSelector.vue:  if (Object.keys(integramApiClient.databases).length === 0) {
./docker-compose.yml:      - SESSION_SECRET=${SESSION_SECRET:-change-this-secret-in-production}
